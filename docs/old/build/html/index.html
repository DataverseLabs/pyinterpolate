
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Welcome to pyinterpolate’s documentation! &#8212; pyinterpolate 0.2 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="welcome-to-pyinterpolate-s-documentation">
<h1>Welcome to pyinterpolate’s documentation!<a class="headerlink" href="#welcome-to-pyinterpolate-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
</div>
<div class="section" id="module-pyinterpolate.calculations.distances.calculate_distances">
<span id="calculate-distances"></span><h1>Calculate Distances<a class="headerlink" href="#module-pyinterpolate.calculations.distances.calculate_distances" title="Permalink to this headline">¶</a></h1>
<dl class="py function">
<dt id="pyinterpolate.calculations.distances.calculate_distances.calc_block_to_block_distance">
<code class="sig-prename descclassname">pyinterpolate.calculations.distances.calculate_distances.</code><code class="sig-name descname">calc_block_to_block_distance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">areas</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/calculations/distances/calculate_distances.html#calc_block_to_block_distance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.calculations.distances.calculate_distances.calc_block_to_block_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Function calculates distances between blocks based on the population points within the block.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>areas</strong> – numpy array or Python list of lists of areal id’s and coordinates per each id [area id, [x, y, val]].</p>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>areal distances - tuple with matrix with areal distances (0) and ids of each row of distances (1):</p>
</dd>
</dl>
<p>(0): [[dist(id0:id0), …, dist(id0:id99)], …, [dist(id99:id0), …, dist(id99:id99)]]</p>
<p>(1): [id0, id1, …, id999]</p>
</dd></dl>

<dl class="py function">
<dt id="pyinterpolate.calculations.distances.calculate_distances.calc_point_to_point_distance">
<code class="sig-prename descclassname">pyinterpolate.calculations.distances.calculate_distances.</code><code class="sig-name descname">calc_point_to_point_distance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points_a</span></em>, <em class="sig-param"><span class="n">points_b</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/calculations/distances/calculate_distances.html#calc_point_to_point_distance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.calculations.distances.calculate_distances.calc_point_to_point_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Function calculates distances between all points in the given array.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points_a</strong> – array of points coordinates,</p></li>
<li><p><strong>points_b</strong> – array of points coordinates, default is None. If None then distance between all points in points_a
is calculated.</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>numpy array of distances between all coordinates.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyinterpolate.data_processing.data_preparation.get_points_within_area">
<span id="data-processing"></span><h1>Data Processing<a class="headerlink" href="#module-pyinterpolate.data_processing.data_preparation.get_points_within_area" title="Permalink to this headline">¶</a></h1>
<dl class="py function">
<dt id="pyinterpolate.data_processing.data_preparation.get_points_within_area.get_points_within_area">
<code class="sig-prename descclassname">pyinterpolate.data_processing.data_preparation.get_points_within_area.</code><code class="sig-name descname">get_points_within_area</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">area_shapefile</span></em>, <em class="sig-param"><span class="n">points_shapefile</span></em>, <em class="sig-param"><span class="n">areal_id_col_name</span></em>, <em class="sig-param"><span class="n">points_val_col_name</span></em>, <em class="sig-param"><span class="n">dropna</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">points_geometry_col_name</span><span class="o">=</span><span class="default_value">'geometry'</span></em>, <em class="sig-param"><span class="n">nans_to_zero</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/data_processing/data_preparation/get_points_within_area.html#get_points_within_area"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.data_processing.data_preparation.get_points_within_area.get_points_within_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Function prepares points data for further processing.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>area_shapefile</strong> – (string) areal data shapefile address,</p></li>
<li><p><strong>points_shapefile</strong> – (string) points data shapefile address,</p></li>
<li><p><strong>areal_id_col_name</strong> – (string) name of the column with id, if None then function uses index column,</p></li>
<li><p><strong>points_val_col_name</strong> – (string) name of the value column of each point, if None then first column other than
points_geometry_col_name is used,</p></li>
<li><p><strong>dropna</strong> – (bool) if True then rows with NaN are deleted (areas without any points).</p></li>
<li><p><strong>points_geometry_col_name</strong> – (string) default ‘geometry’,</p></li>
<li><p><strong>nans_to_zero</strong> – (bool) if true then all nan value is casted to 0,</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>output_points_within_area (numpy array) [area_id, [point_position_x, point_position_y, value]]</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-pyinterpolate.data_processing.data_preparation.prepare_areal_shapefile"></span><dl class="py function">
<dt id="pyinterpolate.data_processing.data_preparation.prepare_areal_shapefile.prepare_areal_shapefile">
<code class="sig-prename descclassname">pyinterpolate.data_processing.data_preparation.prepare_areal_shapefile.</code><code class="sig-name descname">prepare_areal_shapefile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">areal_file_address</span></em>, <em class="sig-param"><span class="n">id_column_name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">value_column_name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">geometry_column_name</span><span class="o">=</span><span class="default_value">'geometry'</span></em>, <em class="sig-param"><span class="n">dropnans</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/data_processing/data_preparation/prepare_areal_shapefile.html#prepare_areal_shapefile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.data_processing.data_preparation.prepare_areal_shapefile.prepare_areal_shapefile" title="Permalink to this definition">¶</a></dt>
<dd><p>Function prepares areal shapefile for processing and transforms it into numpy array. Function returns two lists.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>areal_file_address</strong> – (string) path to the shapefile with areal data,</p></li>
<li><p><strong>id_column_name</strong> – (string) id column name, if not provided then index column is treated as the id,</p></li>
<li><p><strong>value_column_name</strong> – (string) value column name, if not provided then all values are set to nan,</p></li>
<li><p><strong>geometry_column_name</strong> – (string) default is ‘geometry’,</p></li>
<li><p><strong>dropnans</strong> – (bool) if true then rows with nans are dropped.</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>areal_array (numpy array) [area_id, area_geometry, centroid coordinate x, centroid coordinate y, value]</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-pyinterpolate.data_processing.data_preparation.read_data"></span><dl class="py function">
<dt id="pyinterpolate.data_processing.data_preparation.read_data.read_point_data">
<code class="sig-prename descclassname">pyinterpolate.data_processing.data_preparation.read_data.</code><code class="sig-name descname">read_point_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">data_type</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/data_processing/data_preparation/read_data.html#read_point_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.data_processing.data_preparation.read_data.read_point_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Function reads data and converts it into numpy array.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> – (str) path to the file,</p></li>
<li><p><strong>data_type</strong> – (str) data type, available types:
- ‘txt’ for txt files,</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Return data_arr</dt>
<dd class="field-odd"><p>(numpy array) numpy array of coordinates and their values.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyinterpolate.data_processing.data_transformation.get_areal_centroids">
<span id="data-transformation"></span><h1>Data Transformation<a class="headerlink" href="#module-pyinterpolate.data_processing.data_transformation.get_areal_centroids" title="Permalink to this headline">¶</a></h1>
<dl class="py function">
<dt id="pyinterpolate.data_processing.data_transformation.get_areal_centroids.get_centroids">
<code class="sig-prename descclassname">pyinterpolate.data_processing.data_transformation.get_areal_centroids.</code><code class="sig-name descname">get_centroids</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">polygon</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/data_processing/data_transformation/get_areal_centroids.html#get_centroids"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.data_processing.data_transformation.get_areal_centroids.get_centroids" title="Permalink to this definition">¶</a></dt>
<dd><p>Function prepares array for distances calculation from the centroids of areal blocks.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>polygon</strong> – geometry object (polygon).</p>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>centroid position (tuple) centroid position for a given area.</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-pyinterpolate.data_processing.data_transformation.prepare_kriging_data"></span><dl class="py function">
<dt id="pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_ata_data">
<code class="sig-prename descclassname">pyinterpolate.data_processing.data_transformation.prepare_kriging_data.</code><code class="sig-name descname">prepare_ata_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points_within_unknown_area</span></em>, <em class="sig-param"><span class="n">known_areas</span></em>, <em class="sig-param"><span class="n">points_within_known_areas</span></em>, <em class="sig-param"><span class="n">number_of_neighbours</span></em>, <em class="sig-param"><span class="n">max_search_radius</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/data_processing/data_transformation/prepare_kriging_data.html#prepare_ata_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_ata_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Function prepares data for Area to Area Poisson Kriging.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points_within_unknown_area</strong> – (numpy array) array of points and their values within the given area:
[area_id, [point_position_x, point_position_y, value of point]],</p></li>
<li><p><strong>known_areas</strong> – (numpy array) array of known areas in the form:
[area_id, areal_polygon, centroid coordinate x, centroid coordinate y, value at specific location],</p></li>
<li><p><strong>points_within_known_areas</strong> – (numpy array) array of points and their values within the given area:
[[area_id, [point_position_x, point_position_y, value of point]], …],</p></li>
<li><p><strong>number_of_neighbours</strong> – (int) minimum number of neighbours to include in the algorithm,</p></li>
<li><p><strong>max_search_radius</strong> – (float) maximum search radius (if number of neighbours within this search radius is
smaller than number_of_neighbours parameter then additional neighbours are included up to number of neighbors).</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Return output_data</dt>
<dd class="field-odd"><p>(numpy array) array of distances from known locations to the unknown location: [id (known),
areal value - count, [known_point_1 value, unknown_point_1 value, distance_1], total point value].</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_ata_known_areas">
<code class="sig-prename descclassname">pyinterpolate.data_processing.data_transformation.prepare_kriging_data.</code><code class="sig-name descname">prepare_ata_known_areas</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">list_of_points_of_known_areas</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/data_processing/data_transformation/prepare_kriging_data.html#prepare_ata_known_areas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_ata_known_areas" title="Permalink to this definition">¶</a></dt>
<dd><p>Function prepares known areas data for prediction.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>list_of_points_of_known_areas</strong> – (numpy array) list of all areas’ points and their values used for the
prediction.</p>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>(numpy array) list of arrays with areas and distances between them:
[id base, [id other, [base point value, other point value,  distance between points]]].</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_atp_data">
<code class="sig-prename descclassname">pyinterpolate.data_processing.data_transformation.prepare_kriging_data.</code><code class="sig-name descname">prepare_atp_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points_within_unknown_area</span></em>, <em class="sig-param"><span class="n">known_areas</span></em>, <em class="sig-param"><span class="n">points_within_known_areas</span></em>, <em class="sig-param"><span class="n">number_of_neighbours</span></em>, <em class="sig-param"><span class="n">max_search_radius</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/data_processing/data_transformation/prepare_kriging_data.html#prepare_atp_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_atp_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Function prepares data for Area to Point Poisson Kriging.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points_within_unknown_area</strong> – (numpy array) array of points and their values within the given area:
[area_id, [point_position_x, point_position_y, value of point]],</p></li>
<li><p><strong>known_areas</strong> – (numpy array) array of known areas in the form:
[area_id, areal_polygon, centroid coordinate x, centroid coordinate y, value at specific location],</p></li>
<li><p><strong>points_within_known_areas</strong> – (numpy array) array of points and their values within the given area:
[[area_id, [point_position_x, point_position_y, value of point]], …],</p></li>
<li><p><strong>number_of_neighbours</strong> – (int) minimum number of neighbours to include in the algorithm,</p></li>
<li><p><strong>max_search_radius</strong> – (float) maximum search radius (if number of neighbours within this search radius is
smaller than number_of_neighbours parameter then additional neighbours are included up to number of neighbors).</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Return output_data</dt>
<dd class="field-odd"><p>(numpy array) array of distances from known locations to the unknown location:
[id (known), areal value - count, [known_point_1 value, unknown_point_1 value, distance_1], total point value].</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_distances_list_unknown_area">
<code class="sig-prename descclassname">pyinterpolate.data_processing.data_transformation.prepare_kriging_data.</code><code class="sig-name descname">prepare_distances_list_unknown_area</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">unknown_area_points</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/data_processing/data_transformation/prepare_kriging_data.html#prepare_distances_list_unknown_area"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_distances_list_unknown_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Function prepares distances list of unknown (single) area.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>unknown_area_points</strong> – [pt x, pt y, val].</p>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[point value 1, point value 2,  distance between points].</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_kriging_data">
<code class="sig-prename descclassname">pyinterpolate.data_processing.data_transformation.prepare_kriging_data.</code><code class="sig-name descname">prepare_kriging_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">unknown_position</span></em>, <em class="sig-param"><span class="n">data_array</span></em>, <em class="sig-param"><span class="n">number_of_neighbours</span><span class="o">=</span><span class="default_value">10</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/data_processing/data_transformation/prepare_kriging_data.html#prepare_kriging_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_kriging_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Function prepares data for kriging (prediction of unknown value).</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>unknown_position</strong> – array with position of unknown value,</p></li>
<li><p><strong>data_array</strong> – array with known positions and their values,</p></li>
<li><p><strong>number_of_neighbours</strong> – number of the closest locations to the unknown position.</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:
:return: prepared array with dataset which contains:</p>
<blockquote>
<div><p>[[known_position_x, known_position_y, value, distance_to_unknown_position], […]]</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_poisson_kriging_data">
<code class="sig-prename descclassname">pyinterpolate.data_processing.data_transformation.prepare_kriging_data.</code><code class="sig-name descname">prepare_poisson_kriging_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">unknown_area</span></em>, <em class="sig-param"><span class="n">points_within_unknown_area</span></em>, <em class="sig-param"><span class="n">known_areas</span></em>, <em class="sig-param"><span class="n">points_within_known_areas</span></em>, <em class="sig-param"><span class="n">number_of_neighbours</span></em>, <em class="sig-param"><span class="n">max_search_radius</span></em>, <em class="sig-param"><span class="n">weighted</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/data_processing/data_transformation/prepare_kriging_data.html#prepare_poisson_kriging_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_poisson_kriging_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Function prepares data for centroid based Poisson Kriging.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>unknown_area</strong> – (numpy array) unknown area in the form:
[area_id, areal_polygon, centroid coordinate x, centroid coordinate y],</p></li>
<li><p><strong>points_within_unknown_area</strong> – (numpy array) array of points and their values within the given area:
[area_id, [point_position_x, point_position_y, value]],</p></li>
<li><p><strong>known_areas</strong> – (numpy array) array of known areas in the form:
[area_id, areal_polygon, centroid coordinate x, centroid coordinate y, value at specific location],</p></li>
<li><p><strong>points_within_known_areas</strong> – (numpy array) array of points and their values within the given area:
[[area_id, [point_position_x, point_position_y, value]], …],</p></li>
<li><p><strong>number_of_neighbours</strong> – (int) minimum number of neighbours to include in the algorithm,</p></li>
<li><p><strong>max_search_radius</strong> – (float) maximum search radius (if number of neighbours within this search radius is
smaller than number_of_neighbours parameter then additional neighbours are included up to number of neighbors),</p></li>
<li><p><strong>weighted</strong> – (bool) distances weighted by population (True) or not (False).</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>(numpy array) array of distances from known locations to the unknown location:
[id (known), coo_x, coo_y, val, dist_to_unknown, sum_of_vals_within_area].</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyinterpolate.data_visualization.interpolate_raster">
<span id="data-visualization"></span><h1>Data Visualization<a class="headerlink" href="#module-pyinterpolate.data_visualization.interpolate_raster" title="Permalink to this headline">¶</a></h1>
<dl class="py function">
<dt id="pyinterpolate.data_visualization.interpolate_raster.interpolate_raster">
<code class="sig-prename descclassname">pyinterpolate.data_visualization.interpolate_raster.</code><code class="sig-name descname">interpolate_raster</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">dim</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">number_of_neighbors</span><span class="o">=</span><span class="default_value">4</span></em>, <em class="sig-param"><span class="n">semivariogram_model</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/data_visualization/interpolate_raster.html#interpolate_raster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.data_visualization.interpolate_raster.interpolate_raster" title="Permalink to this definition">¶</a></dt>
<dd><p>Function interpolates raster from data points using ordinary kriging.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (numpy array / list) [coordinate x, coordinate y, value],</p></li>
<li><p><strong>dim</strong> – (int) number of pixels (points) of a larger dimension (it could be width or height),</p></li>
<li><p><strong>number_of_neighbors</strong> – (int) default=16, number of points used to interpolate data,</p></li>
<li><p><strong>semivariogram_model</strong> – (TheoreticalSemivariance) default=None, Theoretical Semivariogram model,
if not provided then it is estimated from a given dataset.</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>(numpy arrays) [numpy array of interpolated values, numpy array of interpolation errors],
and list of properties [pixel size, min x, max x, min y, max y]</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyinterpolate.kriging.areal_poisson_kriging.areal_kriging">
<span id="kriging-areal-kriging"></span><h1>Kriging - Areal Kriging<a class="headerlink" href="#module-pyinterpolate.kriging.areal_poisson_kriging.areal_kriging" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="pyinterpolate.kriging.areal_poisson_kriging.areal_kriging.ArealKriging">
<em class="property">class </em><code class="sig-prename descclassname">pyinterpolate.kriging.areal_poisson_kriging.areal_kriging.</code><code class="sig-name descname">ArealKriging</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">semivariogram_model</span></em>, <em class="sig-param"><span class="n">known_areas</span></em>, <em class="sig-param"><span class="n">known_areas_points</span></em>, <em class="sig-param"><span class="n">kriging_type</span><span class="o">=</span><span class="default_value">'ata'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/kriging/areal_poisson_kriging/areal_kriging.html#ArealKriging"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.kriging.areal_poisson_kriging.areal_kriging.ArealKriging" title="Permalink to this definition">¶</a></dt>
<dd><p>Class perform areal kriging of areal semivariogram with point support data.</p>
<p>INITIALIZATION PARAMS:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>semivariogram_model</strong> – (Theoretical Semivariogram) Theoretical Semivariogram used for data interpolation,</p></li>
<li><p><strong>known_areas</strong> – (numpy array) array of areas in the form:
[area_id, areal_polygon, centroid coordinate x, centroid coordinate y, value]</p></li>
<li><p><strong>known_areas_points</strong> – (numpy array) array of points within areas in the form:
[area_id, [point_position_x, point_position_y, value]],</p></li>
<li><p><strong>kriging_type</strong> – (string) default ‘ata’; ‘ata’ - area to area poisson kriging,
‘atp’ - area to point poisson kriging.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="pyinterpolate.kriging.areal_poisson_kriging.areal_kriging.ArealKriging.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">unknown_area_points</span></em>, <em class="sig-param"><span class="n">number_of_neighbours</span></em>, <em class="sig-param"><span class="n">max_search_radius</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/kriging/areal_poisson_kriging/areal_kriging.html#ArealKriging.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.kriging.areal_poisson_kriging.areal_kriging.ArealKriging.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Function predicts areal value in a unknown location based on the area-to-area or area-to-point Poisson Kriging.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>unknown_area_points</strong> – (numpy array) array of points within an unknown area in the form:
[area_id, [point_position_x, point_position_y, value]],</p></li>
<li><p><strong>number_of_neighbours</strong> – (int) minimum number of neighbours to include in the algorithm,</p></li>
<li><p><strong>max_search_radius</strong> – (float) maximum search radius (if number of neighbours within this search radius is
smaller than number_of_neighbours parameter then additional neighbours are included up to number of
neighbors).</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>prediction, error, estimated mean, weights:
[value in unknown location, error, estimated mean, weights].</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.kriging.areal_poisson_kriging.areal_kriging.ArealKriging.regularize_data">
<code class="sig-name descname">regularize_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">number_of_neighbours</span></em>, <em class="sig-param"><span class="n">s_radius</span></em>, <em class="sig-param"><span class="n">data_crs</span><span class="o">=</span><span class="default_value">'EPSG:4326'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/kriging/areal_poisson_kriging/areal_kriging.html#ArealKriging.regularize_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.kriging.areal_poisson_kriging.areal_kriging.ArealKriging.regularize_data" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Function regularizes whole dataset and creates new values and error maps based on the kriging type.</dt><dd><p>If chosen type is area to area then function returns geopandas dataframe with area id, areal geometry,
estimated value, estimated prediction error, RMSE of prediction.
If chosen type is area to point then function returns geopandas dataframe with area id, point coordinates,
estimated value, estimated prediction error, RMSE of areal prediction.</p>
</dd>
</dl>
<p>Function do not predict unknown values, areas with NaN’s are skipped.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>number_of_neighbours</strong> – (int) minimum number of neighbours to include in the algorithm,</p></li>
<li><p><strong>s_radius</strong> – (float) maximum search radius (if number of neighbours within this search radius is
smaller than number_of_neighbours parameter then additional neighbours are included up to number of
neighbors),</p></li>
<li><p><strong>data_crs</strong> – (string) data crs, look into: <a class="reference external" href="https://geopandas.org/projections.html">https://geopandas.org/projections.html</a></p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>regularized dataset (GeoPandas GeoDataFrame object)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-pyinterpolate.kriging.areal_poisson_kriging.centroid_based.centroid_poisson_kriging"></span></div>
<div class="section" id="module-pyinterpolate.kriging.point_kriging.kriging">
<span id="kriging-point-kriging"></span><h1>Kriging - Point Kriging<a class="headerlink" href="#module-pyinterpolate.kriging.point_kriging.kriging" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="pyinterpolate.kriging.point_kriging.kriging.Krige">
<em class="property">class </em><code class="sig-prename descclassname">pyinterpolate.kriging.point_kriging.kriging.</code><code class="sig-name descname">Krige</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">semivariogram_model</span></em>, <em class="sig-param"><span class="n">known_points</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/kriging/point_kriging/kriging.html#Krige"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.kriging.point_kriging.kriging.Krige" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for kriging interpolation of the unknown values in a given location (position). Class takes two arguments
during the initialization:
semivariogram_model - semivariogram model,
known_points - array of known values [x, y, val]</p>
<p>Available methods:</p>
<ul class="simple">
<li><p>ordinary_kriging - ordinary kriging of unknown point value,</p></li>
<li><p>simple_kriging - simple kriging of unknown point value.</p></li>
</ul>
<dl class="simple">
<dt>Method may raise value error if estimated value is below 0. You may use try: statement to overwrite those values</dt><dd><p>with some constant or NaN or you could use different semivariogram model. Sometimes this problem is related to
the input data, especially clusters of points. In this case aggregate those clusters and then estimate
semivariogram and perform kriging.</p>
</dd>
</dl>
<p>INITLIALIZATION PARAMS:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>semivariogram_model</strong> – semivariogram model returned by TheoreticalSemivariogram class</p></li>
<li><p><strong>known_points</strong> – dataset with known values and locations. Each column should represent different dimension and
the last column represents values example: [[dim_x1, dim_y1, val_1], [dim_x2, dim_y2, val_2]].</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="pyinterpolate.kriging.point_kriging.kriging.Krige.ordinary_kriging">
<code class="sig-name descname">ordinary_kriging</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">unknown_location</span></em>, <em class="sig-param"><span class="n">number_of_neighbours</span></em>, <em class="sig-param"><span class="n">test_anomalies</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/kriging/point_kriging/kriging.html#Krige.ordinary_kriging"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.kriging.point_kriging.kriging.Krige.ordinary_kriging" title="Permalink to this definition">¶</a></dt>
<dd><p>Function predicts value at unknown location.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>unknown_location</strong> – (tuple) position of unknown location,</p></li>
<li><p><strong>number_of_neighbours</strong> – (int) number of the closest locations to the unknown position which should be
included in the modeling,</p></li>
<li><p><strong>test_anomalies</strong> – (bool) check if weights are negative.</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>for ordinary kriging:</p>
<blockquote>
<div><ul class="simple">
<li><p>zhat, sigma, w[-1][0], w == [value in unknown location, error, estimated mean, weights]</p></li>
</ul>
</div></blockquote>
<p>for simple kriging:</p>
<blockquote>
<div><ul class="simple">
<li><p>zhat, sigma, area_mean, w == [value in unknown location, error, mean, weights]</p></li>
</ul>
</div></blockquote>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.kriging.point_kriging.kriging.Krige.simple_kriging">
<code class="sig-name descname">simple_kriging</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">unknown_location</span></em>, <em class="sig-param"><span class="n">number_of_neighbours</span></em>, <em class="sig-param"><span class="n">mu</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">test_anomalies</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/kriging/point_kriging/kriging.html#Krige.simple_kriging"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.kriging.point_kriging.kriging.Krige.simple_kriging" title="Permalink to this definition">¶</a></dt>
<dd><p>Function predicts value at unknown location.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>unknown_location</strong> – (tuple) position of unknown location,</p></li>
<li><p><strong>number_of_neighbours</strong> – (int) number of the closest locations to the unknown position which should be
included in the modeling,</p></li>
<li><p><strong>mu</strong> – (float) global mean which should be known before processing. If not given then it is calculated
from the sample but then it may cause a relative large errors (this mean is expectation of the random field,
so without knowledge of the ongoing processes it is unknown).</p></li>
<li><p><strong>test_anomalies</strong> – (bool) check if weights are negative.</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>for ordinary kriging:</p>
<blockquote>
<div><ul class="simple">
<li><p>zhat, sigma, w[-1][0], w == [value in unknown location, error, estimated mean, weights]</p></li>
</ul>
</div></blockquote>
<p>for simple kriging:</p>
<blockquote>
<div><ul class="simple">
<li><p>zhat, sigma, area_mean, w == [value in unknown location, error, mean, weights]</p></li>
</ul>
</div></blockquote>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyinterpolate.semivariance.semivariogram_deconvolution.regularize_semivariogram">
<span id="semivariance-semivariogram-deconvolution"></span><h1>Semivariance - Semivariogram Deconvolution<a class="headerlink" href="#module-pyinterpolate.semivariance.semivariogram_deconvolution.regularize_semivariogram" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="pyinterpolate.semivariance.semivariogram_deconvolution.regularize_semivariogram.RegularizedSemivariogram">
<em class="property">class </em><code class="sig-prename descclassname">pyinterpolate.semivariance.semivariogram_deconvolution.regularize_semivariogram.</code><code class="sig-name descname">RegularizedSemivariogram</code><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_deconvolution/regularize_semivariogram.html#RegularizedSemivariogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_deconvolution.regularize_semivariogram.RegularizedSemivariogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Class performs deconvolution of semivariogram of areal data. Whole procedure is based on the iterative process
described in: Goovaerts P., Kriging and Semivariogram Deconvolution in the Presence of Irregular Geographical
Units, Mathematical Geology 40(1), 101-128, 2008.</p>
<p>Class works as follow:</p>
<ul class="simple">
<li><p>initialize your object (no parameters),</p></li>
<li><p>then use fit() method to build initial point support model,</p></li>
<li><p>the use transform() method to perform semivariogram regularization.</p></li>
</ul>
<p>Class public methods:</p>
<p>fit() - fits areal data and point support data into a model, initialize experimental semivariogram,
theoretical semivariogram model, regularized point support model and deviation.</p>
<p>transform() - performs semivariogram regularization, which is an iterative process.</p>
<p>show_semivariograms() - plots experimental semivariogram of areal data, theoretical curve of areal data,
regularized model values and regularized model theoretical curve.</p>
<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_deconvolution.regularize_semivariogram.RegularizedSemivariogram.export_regularized_model">
<code class="sig-name descname">export_regularized_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_deconvolution/regularize_semivariogram.html#RegularizedSemivariogram.export_regularized_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_deconvolution.regularize_semivariogram.RegularizedSemivariogram.export_regularized_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Function exports final regularized model parameters into specified csv file.</p>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_deconvolution.regularize_semivariogram.RegularizedSemivariogram.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">areal_data</span></em>, <em class="sig-param"><span class="n">areal_lags</span></em>, <em class="sig-param"><span class="n">areal_step_size</span></em>, <em class="sig-param"><span class="n">point_support_data</span></em>, <em class="sig-param"><span class="n">ranges</span><span class="o">=</span><span class="default_value">16</span></em>, <em class="sig-param"><span class="n">weighted_lags</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">store_models</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_deconvolution/regularize_semivariogram.html#RegularizedSemivariogram.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_deconvolution.regularize_semivariogram.RegularizedSemivariogram.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Function fits areal and point support data to the initial regularized models.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>areal_data</strong> – areal data prepared with the function prepare_areal_shapefile(), where data is a numpy array
in the form: [area_id, area_geometry, centroid coordinate x, centroid coordinate y, value],</p></li>
<li><p><strong>areal_lags</strong> – list of lags between each distance,</p></li>
<li><p><strong>areal_step_size</strong> – step size between each lag, usually it is a half of distance between lags,</p></li>
<li><p><strong>point_support_data</strong> – point support data prepared with the function get_points_within_area(), where data is
a numpy array in the form: [area_id, [point_position_x, point_position_y, value]],</p></li>
<li><p><strong>ranges</strong> – (int) number of ranges to test during semivariogram fitting. More steps == more accurate nugget
and range prediction, but longer calculations,</p></li>
<li><p><strong>weighted_lags</strong> – (bool) lags weighted by number of points; if True then during semivariogram fitting error
of each model is weighted by number of points for each lag. In practice it means that more reliable data
(lags) have larger weights and semivariogram is modeled to better fit to those lags,</p></li>
<li><p><strong>store_models</strong> – (bool) if True then experimental, regularized and theoretical models are stored in lists
after each iteration. It is important for a debugging process.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_deconvolution.regularize_semivariogram.RegularizedSemivariogram.show_baseline_semivariograms">
<code class="sig-name descname">show_baseline_semivariograms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_deconvolution/regularize_semivariogram.html#RegularizedSemivariogram.show_baseline_semivariograms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_deconvolution.regularize_semivariogram.RegularizedSemivariogram.show_baseline_semivariograms" title="Permalink to this definition">¶</a></dt>
<dd><p>Function shows experimental semivariogram, initial theoretical semivariogram and
initial regularized semivariogram after fit() operation.</p>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_deconvolution.regularize_semivariogram.RegularizedSemivariogram.show_semivariograms">
<code class="sig-name descname">show_semivariograms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_deconvolution/regularize_semivariogram.html#RegularizedSemivariogram.show_semivariograms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_deconvolution.regularize_semivariogram.RegularizedSemivariogram.show_semivariograms" title="Permalink to this definition">¶</a></dt>
<dd><p>Function shows experimental semivariogram, theoretical semivariogram and regularized semivariogram after
semivariogram regularization.</p>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_deconvolution.regularize_semivariogram.RegularizedSemivariogram.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_iters</span><span class="o">=</span><span class="default_value">25</span></em>, <em class="sig-param"><span class="n">min_deviation_ratio</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">min_diff_decrease</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">min_diff_decrease_reps</span><span class="o">=</span><span class="default_value">3</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_deconvolution/regularize_semivariogram.html#RegularizedSemivariogram.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_deconvolution.regularize_semivariogram.RegularizedSemivariogram.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Function transofrms fitted data and performs semivariogram regularziation iterative procedure.</p>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_iters</strong> – maximum number of iterations,</p></li>
<li><p><strong>min_deviation_ratio</strong> – minimum ration between deviation and initial deviation (D(i) / D(0)) below each
algorithm is stopped,</p></li>
<li><p><strong>min_diff_decrease</strong> – minimum absolute difference between new and optimal deviation divided by optimal
deviation: ABS(D(i) - D(opt)) / D(opt). If it is recorded n times (controled by the min_diff_d_stat_reps
param) then algorithm is stopped,</p></li>
<li><p><strong>min_diff_decrease_reps</strong> – (int) number of iterations when algorithm is stopped if condition
min_diff_d_stat is fulfilled.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyinterpolate.semivariance.semivariogram_estimation.calculate_semivariance">
<span id="semivariance-semivariogram-estimation"></span><h1>Semivariance - Semivariogram Estimation<a class="headerlink" href="#module-pyinterpolate.semivariance.semivariogram_estimation.calculate_semivariance" title="Permalink to this headline">¶</a></h1>
<dl class="py function">
<dt id="pyinterpolate.semivariance.semivariogram_estimation.calculate_semivariance.calculate_semivariance">
<code class="sig-prename descclassname">pyinterpolate.semivariance.semivariogram_estimation.calculate_semivariance.</code><code class="sig-name descname">calculate_semivariance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">lags</span></em>, <em class="sig-param"><span class="n">step_size</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_estimation/calculate_semivariance.html#calculate_semivariance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_estimation.calculate_semivariance.calculate_semivariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Function calculates semivariance of a given set of points.</p>
<p>Equation for calculation is:</p>
<blockquote>
<div><p>semivariance = 1 / (2 * N) * SUM(i=1, N) [z(x_i + h) - z(x_i)]^2</p>
</div></blockquote>
<p>where:</p>
<blockquote>
<div><ul class="simple">
<li><p>N - number of observation pairs,</p></li>
<li><p>h - distance (lag),</p></li>
<li><p>z(x_i) - value at location z_i,</p></li>
<li><p>(x_i + h) - location at a distance h from x_i.</p></li>
</ul>
</div></blockquote>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – array of coordinates and their values,</p></li>
<li><p><strong>lags</strong> – array of lags between points,</p></li>
<li><p><strong>step_size</strong> – distance which should be included in the gamma parameter which enhances range of interest.</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>semivariance: numpy array of pair of lag and semivariance values where:</p>
<ul class="simple">
<li><p>semivariance[0] = array of lags,</p></li>
<li><p>semivariance[1] = array of lag’s values,</p></li>
<li><p>semivariance[2] = array of number of points in each lag.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyinterpolate.semivariance.semivariogram_estimation.calculate_semivariance.calculate_weighted_semivariance">
<code class="sig-prename descclassname">pyinterpolate.semivariance.semivariogram_estimation.calculate_semivariance.</code><code class="sig-name descname">calculate_weighted_semivariance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">lags</span></em>, <em class="sig-param"><span class="n">step_size</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_estimation/calculate_semivariance.html#calculate_weighted_semivariance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_estimation.calculate_semivariance.calculate_weighted_semivariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Function calculates weighted semivariance following Monestiez et al.:</p>
<p>A. Monestiez P, Dubroca L, Bonnin E, Durbec JP, Guinet C: Comparison of model based geostatistical methods
in ecology: application to fin whale spatial distribution in northwestern Mediterranean Sea.
In Geostatistics Banff 2004 Volume 2. Edited by: Leuangthong O, Deutsch CV. Dordrecht, The Netherlands,
Kluwer Academic Publishers; 2005:777-786.</p>
<p>B. Monestiez P, Dubroca L, Bonnin E, Durbec JP, Guinet C: Geostatistical modelling of spatial distribution
of Balenoptera physalus in the northwestern Mediterranean Sea from sparse count data and heterogeneous
observation efforts. Ecological Modelling 2006 in press.</p>
<p>Equation for calculation is:</p>
<dl class="simple">
<dt>s(h) = [1 / (2 * SUM(a=1, N(h)) (n(u_a) * n(u_a + h)) /…</dt><dd><p>/ (n(u_a) + n(u_a + h)))] <a href="#id1"><span class="problematic" id="id2">*</span></a>…
* SUM(a=1, N(h)) {[(n(u_a) * n(u_a + h)) / (n(u_a) + n(u_a + h))] * [(z(u_a) - z(u_a + h))^2] - m’}</p>
</dd>
</dl>
<p>where:</p>
<ul class="simple">
<li><p>s(h) - Semivariogram of the risk,</p></li>
<li><p>n(u_a) - size of the population at risk in the unit a,</p></li>
<li><p>z(u_a) - mortality rate at the unit a,</p></li>
<li><p>u_a + h - area at the distance (h) from the analyzed area,</p></li>
<li><p>m’ - population weighted mean of rates.</p></li>
</ul>
<p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (numpy array) [coordinate x, coordinate y, value, weight],</p></li>
<li><p><strong>lags</strong> – (array) of lags [lag1, lag2, lag…]</p></li>
<li><p><strong>step_size</strong> – step size of search radius.</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>semivariance: numpy array of pair of lag and semivariance values where:</p>
<ul class="simple">
<li><p>semivariance[0] = array of lags</p></li>
<li><p>semivariance[1] = array of lag’s values</p></li>
<li><p>semivariance[2] = array of number of points in each lag.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyinterpolate.semivariance.semivariogram_fit.fit_semivariance">
<span id="semivariance-fit-semivariogram"></span><h1>Semivariance - Fit Semivariogram<a class="headerlink" href="#module-pyinterpolate.semivariance.semivariogram_fit.fit_semivariance" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram">
<em class="property">class </em><code class="sig-prename descclassname">pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.</code><code class="sig-name descname">TheoreticalSemivariogram</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points_array</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">empirical_semivariance</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_fit/fit_semivariance.html#TheoreticalSemivariogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for calculating theoretical semivariogram. Class takes two parameters during initialization:
points_array - analysed points where the last column is representing values, typically DEM
empirical_semivariance - semivariance where first row of array represents lags and the second row
represents semivariance’s values for given lag</p>
<p>Available methods:</p>
<ul class="simple">
<li><p>predict() - method predicts value of the unknown point based on the chosen model,</p></li>
<li><p>fit_semivariance() - returns given model,</p></li>
<li><p>find_optimal_model() - returns optimal model for given experimental semivariogram.</p></li>
</ul>
<p>Available theoretical models:</p>
<ul class="simple">
<li><p>spherical_model(distance, nugget, sill, semivar_range)</p></li>
<li><p>gaussian_model(distance, nugget, sill, semivar_range)</p></li>
<li><p>exponential_model(distance, nugget, sill, semivar_range)</p></li>
<li><p>linear_model(distance, nugget, sill, semivar_range)</p></li>
</ul>
<p>Additional methods:</p>
<ul class="simple">
<li><p>calculate_base_error(),</p></li>
<li><p>show_experimental_semivariogram() - shows semivariogram which is a part of the class object’s instance,</p></li>
<li><p>show_semivariogram() - shows experimental semivariogram with theoretical model (if it was calculated).</p></li>
</ul>
<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.calculate_base_error">
<code class="sig-name descname">calculate_base_error</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_fit/fit_semivariance.html#TheoreticalSemivariogram.calculate_base_error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.calculate_base_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Method calculates base error as a squared difference between experimental semivariogram and
a “flat line” on the x-axis (only zeros)</p>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.exponential_model">
<em class="property">static </em><code class="sig-name descname">exponential_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">distance</span></em>, <em class="sig-param"><span class="n">nugget</span></em>, <em class="sig-param"><span class="n">sill</span></em>, <em class="sig-param"><span class="n">semivar_range</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_fit/fit_semivariance.html#TheoreticalSemivariogram.exponential_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.exponential_model" title="Permalink to this definition">¶</a></dt>
<dd><p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distance</strong> – array of ranges from empirical semivariance,</p></li>
<li><p><strong>nugget</strong> – scalar,</p></li>
<li><p><strong>sill</strong> – scalar,</p></li>
<li><p><strong>semivar_range</strong> – optimal range calculated by fit_semivariance method.</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an array of modeled values for given range. Values are calculated based on the exponential model.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.export_model">
<code class="sig-name descname">export_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_fit/fit_semivariance.html#TheoreticalSemivariogram.export_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.export_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Function exports semivariance model to the csv file with columns:</p>
<ul class="simple">
<li><p>name: [model name],</p></li>
<li><p>nugget: [value],</p></li>
<li><p>sill: [value],</p></li>
<li><p>range: [value]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.find_optimal_model">
<code class="sig-name descname">find_optimal_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weighted</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">number_of_ranges</span><span class="o">=</span><span class="default_value">16</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_fit/fit_semivariance.html#TheoreticalSemivariogram.find_optimal_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.find_optimal_model" title="Permalink to this definition">¶</a></dt>
<dd><p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weighted</strong> – <p>default=False. If True then each lag is weighted by:</p>
<p>sqrt(N(h))/gamma_{exp}(h)</p>
<p>where:</p>
<ul>
<li><p>N(h) - number of point pairs in a given range, gamma_{exp}(h) - value of experimental semivariogram for h.</p></li>
</ul>
</p></li>
<li><p><strong>number_of_ranges</strong> – deafult = 16. Used to create an array of equidistant ranges
between minimal range of empirical semivariance and maximum range of empirical semivariance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.fit_semivariance">
<code class="sig-name descname">fit_semivariance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">model_type</span></em>, <em class="sig-param"><span class="n">number_of_ranges</span><span class="o">=</span><span class="default_value">16</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_fit/fit_semivariance.html#TheoreticalSemivariogram.fit_semivariance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.fit_semivariance" title="Permalink to this definition">¶</a></dt>
<dd><p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model_type</strong> – ‘exponential’, ‘gaussian’, ‘linear’, ‘spherical’,</p></li>
<li><p><strong>number_of_ranges</strong> – deafult = 16. Used to create an array of equidistant ranges
between minimal range of empirical semivariance and maximum range of empirical semivariance.</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>(model_type, model parameters)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.gaussian_model">
<em class="property">static </em><code class="sig-name descname">gaussian_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">distance</span></em>, <em class="sig-param"><span class="n">nugget</span></em>, <em class="sig-param"><span class="n">sill</span></em>, <em class="sig-param"><span class="n">semivar_range</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_fit/fit_semivariance.html#TheoreticalSemivariogram.gaussian_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.gaussian_model" title="Permalink to this definition">¶</a></dt>
<dd><p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distance</strong> – array of ranges from empirical semivariance,</p></li>
<li><p><strong>nugget</strong> – scalar,</p></li>
<li><p><strong>sill</strong> – scalar,</p></li>
<li><p><strong>semivar_range</strong> – optimal range calculated by fit_semivariance method.</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an array of modeled values for given range. Values are calculated based on the gaussian model.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.import_model">
<code class="sig-name descname">import_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_fit/fit_semivariance.html#TheoreticalSemivariogram.import_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.import_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Function imports semivariance model and updates it’s parameters</p>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.linear_model">
<em class="property">static </em><code class="sig-name descname">linear_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">distance</span></em>, <em class="sig-param"><span class="n">nugget</span></em>, <em class="sig-param"><span class="n">sill</span></em>, <em class="sig-param"><span class="n">semivar_range</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_fit/fit_semivariance.html#TheoreticalSemivariogram.linear_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.linear_model" title="Permalink to this definition">¶</a></dt>
<dd><p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distance</strong> – array of ranges from empirical semivariance,</p></li>
<li><p><strong>nugget</strong> – scalar,</p></li>
<li><p><strong>sill</strong> – scalar,</p></li>
<li><p><strong>semivar_range</strong> – optimal range calculated by fit_semivariance method.</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an array of modeled values for given range. Values are calculated based on the linear model.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">distances</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_fit/fit_semivariance.html#TheoreticalSemivariogram.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>distances</strong> – array of distances from points of known locations and values to the point of</p>
</dd>
</dl>
<p>unknown value,</p>
<p>OUTPUT:
:return: model with predicted values.</p>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.show_experimental_semivariogram">
<code class="sig-name descname">show_experimental_semivariogram</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_fit/fit_semivariance.html#TheoreticalSemivariogram.show_experimental_semivariogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.show_experimental_semivariogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Function shows experimental semivariogram of a given model.</p>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.show_semivariogram">
<code class="sig-name descname">show_semivariogram</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_fit/fit_semivariance.html#TheoreticalSemivariogram.show_semivariogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.show_semivariogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Function shows experimental and theoretical semivariogram in one plot.</p>
</dd></dl>

<dl class="py method">
<dt id="pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.spherical_model">
<em class="property">static </em><code class="sig-name descname">spherical_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">distance</span></em>, <em class="sig-param"><span class="n">nugget</span></em>, <em class="sig-param"><span class="n">sill</span></em>, <em class="sig-param"><span class="n">semivar_range</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyinterpolate/semivariance/semivariogram_fit/fit_semivariance.html#TheoreticalSemivariogram.spherical_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinterpolate.semivariance.semivariogram_fit.fit_semivariance.TheoreticalSemivariogram.spherical_model" title="Permalink to this definition">¶</a></dt>
<dd><p>INPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distance</strong> – array of ranges from empirical semivariance,</p></li>
<li><p><strong>nugget</strong> – scalar,</p></li>
<li><p><strong>sill</strong> – scalar,</p></li>
<li><p><strong>semivar_range</strong> – optimal range calculated by fit_semivariance method.</p></li>
</ul>
</dd>
</dl>
<p>OUTPUT:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an array of modeled values for given range. Values are calculated based on the spherical model.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">pyinterpolate</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Szymon Molinski.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>