
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyinterpolate.data_processing.data_transformation.prepare_kriging_data &#8212; Pyinterpolate 0.2.0 documentation</title>
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pyinterpolate.data_processing.data_transformation.prepare_kriging_data</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyinterpolate.calculations.distances.calculate_distances</span> <span class="kn">import</span> <span class="n">calc_point_to_point_distance</span><span class="p">,</span>\
    <span class="n">calc_block_to_block_distance</span>
<span class="kn">from</span> <span class="nn">pyinterpolate.data_processing.data_preparation.set_areal_weights</span> <span class="kn">import</span> <span class="n">get_total_value_of_area</span>


<div class="viewcode-block" id="prepare_kriging_data"><a class="viewcode-back" href="../../../../index.html#pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_kriging_data">[docs]</a><span class="k">def</span> <span class="nf">prepare_kriging_data</span><span class="p">(</span><span class="n">unknown_position</span><span class="p">,</span> <span class="n">data_array</span><span class="p">,</span> <span class="n">number_of_neighbours</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function prepares data for kriging (prediction of unknown value).</span>

<span class="sd">    INPUT:</span>

<span class="sd">    :param unknown_position: array with position of unknown value,</span>
<span class="sd">    :param data_array: array with known positions and their values,</span>
<span class="sd">    :param number_of_neighbours: number of the closest locations to the unknown position.</span>

<span class="sd">    OUTPUT:</span>
<span class="sd">    :return: prepared array with dataset which contains:</span>
<span class="sd">        [[known_position_x, known_position_y, value, distance_to_unknown_position], [...]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Distances to unknown point</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">unknown_position</span><span class="p">])</span>

    <span class="n">known_pos</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="n">calc_point_to_point_distance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">known_pos</span><span class="p">)</span>

    <span class="c1"># Prepare data for kriging</span>
    <span class="n">kriging_output_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">data_array</span><span class="p">,</span> <span class="n">dists</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
    <span class="n">kriging_output_array</span> <span class="o">=</span> <span class="n">kriging_output_array</span><span class="p">[</span><span class="n">kriging_output_array</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>
    <span class="n">prepared_data</span> <span class="o">=</span> <span class="n">kriging_output_array</span><span class="p">[:</span><span class="n">number_of_neighbours</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">prepared_data</span></div>


<div class="viewcode-block" id="prepare_poisson_kriging_data"><a class="viewcode-back" href="../../../../index.html#pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_poisson_kriging_data">[docs]</a><span class="k">def</span> <span class="nf">prepare_poisson_kriging_data</span><span class="p">(</span><span class="n">unknown_area</span><span class="p">,</span> <span class="n">points_within_unknown_area</span><span class="p">,</span>
                                 <span class="n">known_areas</span><span class="p">,</span> <span class="n">points_within_known_areas</span><span class="p">,</span>
                                 <span class="n">number_of_neighbours</span><span class="p">,</span> <span class="n">max_search_radius</span><span class="p">,</span>
                                 <span class="n">weighted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function prepares data for centroid based Poisson Kriging.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    :param unknown_area: (numpy array) unknown area in the form:</span>
<span class="sd">        [area_id, areal_polygon, centroid coordinate x, centroid coordinate y],</span>
<span class="sd">    :param points_within_unknown_area: (numpy array) array of points and their values within the given area:</span>
<span class="sd">        [area_id, [point_position_x, point_position_y, value]],</span>
<span class="sd">    :param known_areas: (numpy array) array of known areas in the form:</span>
<span class="sd">        [area_id, areal_polygon, centroid coordinate x, centroid coordinate y, value at specific location],</span>
<span class="sd">    :param points_within_known_areas: (numpy array) array of points and their values within the given area:</span>
<span class="sd">        [[area_id, [point_position_x, point_position_y, value]], ...],</span>
<span class="sd">    :param number_of_neighbours: (int) minimum number of neighbours to include in the algorithm,</span>
<span class="sd">    :param max_search_radius: (float) maximum search radius (if number of neighbours within this search radius is</span>
<span class="sd">        smaller than number_of_neighbours parameter then additional neighbours are included up to number of neighbors),</span>
<span class="sd">    :param weighted: (bool) distances weighted by population (True) or not (False).</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">    :return: (numpy array) array of distances from known locations to the unknown location:</span>
<span class="sd">        [id (known), coo_x, coo_y, val, dist_to_unknown, sum_of_vals_within_area].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Prepare data</span>
    <span class="n">cx_cy</span> <span class="o">=</span> <span class="n">unknown_area</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cx_cy</span><span class="p">)</span>

    <span class="n">known_centroids</span> <span class="o">=</span> <span class="n">known_areas</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">kc_ids</span> <span class="o">=</span> <span class="n">known_centroids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">kc_vals</span> <span class="o">=</span> <span class="n">known_centroids</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">kc_pos</span> <span class="o">=</span> <span class="n">known_centroids</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Build set for Poisson Kriging</span>

    <span class="k">if</span> <span class="n">weighted</span><span class="p">:</span>
        <span class="n">known_areas_pts</span> <span class="o">=</span> <span class="n">points_within_known_areas</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">dists</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># [id_known, dist]</span>

        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">known_areas_pts</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">calc_block_to_block_distance</span><span class="p">([</span><span class="n">pt</span><span class="p">,</span> <span class="n">points_within_unknown_area</span><span class="p">])</span>
            <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dists</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">kriging_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">kc_ids</span><span class="p">,</span> <span class="n">kc_pos</span><span class="p">,</span> <span class="n">kc_vals</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>  <span class="c1"># [id, coo_x, coo_y, val, dist_to_unkn]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">calc_point_to_point_distance</span><span class="p">(</span><span class="n">kc_pos</span><span class="p">,</span> <span class="p">[</span><span class="n">r</span><span class="p">])</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">dists</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">dists</span><span class="o">.</span><span class="n">T</span>
        <span class="n">kriging_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">kc_ids</span><span class="p">,</span> <span class="n">kc_pos</span><span class="p">,</span> <span class="n">kc_vals</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>  <span class="c1"># [id, coo_x, coo_y, val, dist_to_unkn]</span>

    <span class="c1"># sort by distance</span>
    <span class="n">kriging_data</span> <span class="o">=</span> <span class="n">kriging_data</span><span class="p">[</span><span class="n">kriging_data</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>

    <span class="c1"># Get distances in max search radius</span>
    <span class="n">max_search_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">kriging_data</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_search_radius</span><span class="p">)</span>
    <span class="n">output_data</span> <span class="o">=</span> <span class="n">kriging_data</span><span class="p">[:</span><span class="n">max_search_pos</span><span class="p">]</span>

    <span class="c1"># check number of observations</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">number_of_neighbours</span><span class="p">:</span>
        <span class="n">output_data</span> <span class="o">=</span> <span class="n">kriging_data</span><span class="p">[:</span><span class="n">number_of_neighbours</span><span class="p">]</span>

    <span class="c1"># get total points&#39; value in each id from prepared datasets and append it to the array</span>

    <span class="n">points_vals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">output_data</span><span class="p">:</span>
        <span class="n">areal_id</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">points_in_area</span> <span class="o">=</span> <span class="n">points_within_known_areas</span><span class="p">[</span><span class="n">points_within_known_areas</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">areal_id</span><span class="p">]</span>
        <span class="n">total_val</span> <span class="o">=</span> <span class="n">get_total_value_of_area</span><span class="p">(</span><span class="n">points_in_area</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">points_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total_val</span><span class="p">)</span>

    <span class="n">output_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">output_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_vals</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">output_data</span></div>


<span class="k">def</span> <span class="nf">_merge_vals_and_distances</span><span class="p">(</span><span class="n">known_vals</span><span class="p">,</span> <span class="n">unknown_vals</span><span class="p">,</span> <span class="n">distances_array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function prepares array of point values and respective distances for Poisson Kriging calculations</span>
<span class="sd">    :param known_vals: (numpy array) list of known area point values - number of rows of output array,</span>
<span class="sd">    :param unknown_vals: (numpy array) list of unknown area point values - number of columns of output array,</span>
<span class="sd">    :param distances_array: (numpy array) distances array with the same number of rows as known_vals and</span>
<span class="sd">        the same number of columns as unknown_vals arrays,</span>
<span class="sd">    :return output_arr: (numpy array) array of [known point value, unknown point value, distance between points]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k_idx</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">known_vals</span><span class="p">):</span>
        <span class="n">output_list</span> <span class="o">=</span> <span class="p">[[</span><span class="n">value</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">distances_array</span><span class="p">[</span><span class="n">k_idx</span><span class="p">,</span> <span class="n">u_idx</span><span class="p">]]</span> <span class="k">for</span> <span class="n">u_idx</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unknown_vals</span><span class="p">)]</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_list</span><span class="p">)</span>
    <span class="n">output_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output_arr</span>


<div class="viewcode-block" id="prepare_ata_data"><a class="viewcode-back" href="../../../../index.html#pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_ata_data">[docs]</a><span class="k">def</span> <span class="nf">prepare_ata_data</span><span class="p">(</span><span class="n">points_within_unknown_area</span><span class="p">,</span>
                     <span class="n">known_areas</span><span class="p">,</span> <span class="n">points_within_known_areas</span><span class="p">,</span>
                     <span class="n">number_of_neighbours</span><span class="p">,</span> <span class="n">max_search_radius</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function prepares data for Area to Area Poisson Kriging.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    :param points_within_unknown_area: (numpy array) array of points and their values within the given area:</span>
<span class="sd">        [area_id, [point_position_x, point_position_y, value of point]],</span>
<span class="sd">    :param known_areas: (numpy array) array of known areas in the form:</span>
<span class="sd">        [area_id, areal_polygon, centroid coordinate x, centroid coordinate y, value at specific location],</span>
<span class="sd">    :param points_within_known_areas: (numpy array) array of points and their values within the given area:</span>
<span class="sd">        [[area_id, [point_position_x, point_position_y, value of point]], ...],</span>
<span class="sd">    :param number_of_neighbours: (int) minimum number of neighbours to include in the algorithm,</span>
<span class="sd">    :param max_search_radius: (float) maximum search radius (if number of neighbours within this search radius is</span>
<span class="sd">        smaller than number_of_neighbours parameter then additional neighbours are included up to number of neighbors).</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">    :return output_data: (numpy array) array of distances from known locations to the unknown location: [id (known),</span>
<span class="sd">        areal value - count, [known_point_1 value, unknown_point_1 value, distance_1], total point value].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Initialize set</span>

    <span class="n">kriging_areas_ids</span> <span class="o">=</span> <span class="n">known_areas</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">kriging_areal_values</span> <span class="o">=</span> <span class="n">known_areas</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Build set for Area to Area Poisson Kriging - sort areas with distance</span>

    <span class="n">known_areas_pts</span> <span class="o">=</span> <span class="n">points_within_known_areas</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">dists</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># [id_known, dist to unknown]</span>

    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">known_areas_pts</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">calc_block_to_block_distance</span><span class="p">([</span><span class="n">pt</span><span class="p">,</span> <span class="n">points_within_unknown_area</span><span class="p">])</span>
        <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dists</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">kriging_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">kriging_areas_ids</span><span class="p">,</span> <span class="n">kriging_areal_values</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>  <span class="c1"># [id, areal val, dist_to_unkn]</span>

    <span class="c1"># sort by distance</span>
    <span class="n">kriging_data</span> <span class="o">=</span> <span class="n">kriging_data</span><span class="p">[</span><span class="n">kriging_data</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>

    <span class="c1"># Get distances in max search radius</span>
    <span class="n">max_search_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">kriging_data</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_search_radius</span><span class="p">)</span>
    <span class="n">output_data</span> <span class="o">=</span> <span class="n">kriging_data</span><span class="p">[:</span><span class="n">max_search_pos</span><span class="p">]</span>

    <span class="c1"># check number of observations</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">number_of_neighbours</span><span class="p">:</span>
        <span class="n">output_data</span> <span class="o">=</span> <span class="n">kriging_data</span><span class="p">[:</span><span class="n">number_of_neighbours</span><span class="p">]</span>

    <span class="c1"># for each of prepared id prepare distances list with points&#39; weights for semivariogram calculation</span>

    <span class="n">points_vals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">points_in_unknown_area</span> <span class="o">=</span> <span class="n">points_within_unknown_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">vals_in_unknown_area</span> <span class="o">=</span> <span class="n">points_within_unknown_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">output_data</span><span class="p">:</span>
        <span class="n">areal_id</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">areal_value</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">known_area</span> <span class="o">=</span> <span class="n">points_within_known_areas</span><span class="p">[</span><span class="n">points_within_known_areas</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">areal_id</span><span class="p">]</span>
        <span class="n">known_area</span> <span class="o">=</span> <span class="n">known_area</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">points_in_known_area</span> <span class="o">=</span> <span class="n">known_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">vals_in_known_area</span> <span class="o">=</span> <span class="n">known_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">distances_array</span> <span class="o">=</span> <span class="n">calc_point_to_point_distance</span><span class="p">(</span><span class="n">points_in_known_area</span><span class="p">,</span> <span class="n">points_in_unknown_area</span><span class="p">)</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">_merge_vals_and_distances</span><span class="p">(</span><span class="n">vals_in_known_area</span><span class="p">,</span> <span class="n">vals_in_unknown_area</span><span class="p">,</span> <span class="n">distances_array</span><span class="p">)</span>
        <span class="n">total_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">known_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">generated_array</span> <span class="o">=</span> <span class="p">[</span><span class="n">areal_id</span><span class="p">,</span> <span class="n">areal_value</span><span class="p">,</span> <span class="n">merged</span><span class="p">,</span> <span class="n">total_val</span><span class="p">]</span>  <span class="c1"># [id, value, [known point value,</span>
                                                                      <span class="c1">#              unknown point value,</span>
                                                                      <span class="c1">#              distance between points],</span>
                                                                      <span class="c1">#              total point value]</span>
        <span class="n">points_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">generated_array</span><span class="p">)</span>

    <span class="n">output_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_vals</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output_data</span></div>


<div class="viewcode-block" id="prepare_ata_known_areas"><a class="viewcode-back" href="../../../../index.html#pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_ata_known_areas">[docs]</a><span class="k">def</span> <span class="nf">prepare_ata_known_areas</span><span class="p">(</span><span class="n">list_of_points_of_known_areas</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function prepares known areas data for prediction.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    :param list_of_points_of_known_areas: (numpy array) list of all areas&#39; points and their values used for the</span>
<span class="sd">        prediction.</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">    :return: (numpy array) list of arrays with areas and distances between them:</span>
<span class="sd">        [id base, [id other, [base point value, other point value,  distance between points]]].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_distances_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pt1</span> <span class="ow">in</span> <span class="n">list_of_points_of_known_areas</span><span class="p">:</span>

        <span class="n">id_base</span> <span class="o">=</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">list_of_distances_from_base</span> <span class="o">=</span> <span class="p">[</span><span class="n">id_base</span><span class="p">,</span> <span class="p">[]]</span>

        <span class="n">points_in_base_area</span> <span class="o">=</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">vals_in_base_area</span> <span class="o">=</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">pt2</span> <span class="ow">in</span> <span class="n">list_of_points_of_known_areas</span><span class="p">:</span>

            <span class="n">id_other</span> <span class="o">=</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">points_in_other_area</span> <span class="o">=</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">vals_in_other_area</span> <span class="o">=</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">distances_array</span> <span class="o">=</span> <span class="n">calc_point_to_point_distance</span><span class="p">(</span><span class="n">points_in_base_area</span><span class="p">,</span> <span class="n">points_in_other_area</span><span class="p">)</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">_merge_vals_and_distances</span><span class="p">(</span><span class="n">vals_in_base_area</span><span class="p">,</span> <span class="n">vals_in_other_area</span><span class="p">,</span> <span class="n">distances_array</span><span class="p">)</span>

            <span class="n">list_of_distances_from_base</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">id_other</span><span class="p">,</span> <span class="n">merged</span><span class="p">])</span>
        <span class="n">all_distances_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">list_of_distances_from_base</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_distances_list</span><span class="p">)</span></div>


<div class="viewcode-block" id="prepare_distances_list_unknown_area"><a class="viewcode-back" href="../../../../index.html#pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_distances_list_unknown_area">[docs]</a><span class="k">def</span> <span class="nf">prepare_distances_list_unknown_area</span><span class="p">(</span><span class="n">unknown_area_points</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function prepares distances list of unknown (single) area.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    :param unknown_area_points: [pt x, pt y, val].</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">    :return: [point value 1, point value 2,  distance between points].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="n">calc_point_to_point_distance</span><span class="p">(</span><span class="n">unknown_area_points</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">unknown_area_points</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">merged</span> <span class="o">=</span> <span class="n">_merge_vals_and_distances</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">dists</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_merge_point_val_and_distances</span><span class="p">(</span><span class="n">unknown_point_val</span><span class="p">,</span> <span class="n">known_vals</span><span class="p">,</span> <span class="n">distances_array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function prepares array of point values and respective distances for Poisson Kriging calculations.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    :param unknown_point_val: (float) unknown point value,</span>
<span class="sd">    :param known_vals: (numpy array) list of unknown area point values,</span>
<span class="sd">    :param distances_array: (numpy array) distances from unknown area point to known area points.</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">    :return output_arr: (numpy array) array of [unknown point value, [known points values, distance between points]].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">distances_array</span> <span class="o">=</span> <span class="n">distances_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">otp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">known_vals</span><span class="p">,</span> <span class="n">distances_array</span><span class="p">)])</span>

    <span class="n">output_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">unknown_point_val</span><span class="p">,</span> <span class="n">otp</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">output_arr</span>

<div class="viewcode-block" id="prepare_atp_data"><a class="viewcode-back" href="../../../../index.html#pyinterpolate.data_processing.data_transformation.prepare_kriging_data.prepare_atp_data">[docs]</a><span class="k">def</span> <span class="nf">prepare_atp_data</span><span class="p">(</span><span class="n">points_within_unknown_area</span><span class="p">,</span>
                     <span class="n">known_areas</span><span class="p">,</span> <span class="n">points_within_known_areas</span><span class="p">,</span>
                     <span class="n">number_of_neighbours</span><span class="p">,</span> <span class="n">max_search_radius</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function prepares data for Area to Point Poisson Kriging.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    :param points_within_unknown_area: (numpy array) array of points and their values within the given area:</span>
<span class="sd">        [area_id, [point_position_x, point_position_y, value of point]],</span>
<span class="sd">    :param known_areas: (numpy array) array of known areas in the form:</span>
<span class="sd">        [area_id, areal_polygon, centroid coordinate x, centroid coordinate y, value at specific location],</span>
<span class="sd">    :param points_within_known_areas: (numpy array) array of points and their values within the given area:</span>
<span class="sd">        [[area_id, [point_position_x, point_position_y, value of point]], ...],</span>
<span class="sd">    :param number_of_neighbours: (int) minimum number of neighbours to include in the algorithm,</span>
<span class="sd">    :param max_search_radius: (float) maximum search radius (if number of neighbours within this search radius is</span>
<span class="sd">        smaller than number_of_neighbours parameter then additional neighbours are included up to number of neighbors).</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">    :return output_data: (numpy array) array of distances from known locations to the unknown location:</span>
<span class="sd">        [id (known), areal value - count, [known_point_1 value, unknown_point_1 value, distance_1], total point value].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Initialize set</span>

    <span class="n">kriging_areas_ids</span> <span class="o">=</span> <span class="n">known_areas</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">kriging_areal_values</span> <span class="o">=</span> <span class="n">known_areas</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Build set for Area to Area Poisson Kriging - sort areas with distance</span>

    <span class="n">known_areas_pts</span> <span class="o">=</span> <span class="n">points_within_known_areas</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">dists</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># [id_known, dist to unknown]</span>

    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">known_areas_pts</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">calc_block_to_block_distance</span><span class="p">([</span><span class="n">pt</span><span class="p">,</span> <span class="n">points_within_unknown_area</span><span class="p">])</span>
        <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dists</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">kriging_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">kriging_areas_ids</span><span class="p">,</span> <span class="n">kriging_areal_values</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>  <span class="c1"># [id, areal val, dist_to_unkn]</span>

    <span class="c1"># sort by distance</span>
    <span class="n">kriging_data</span> <span class="o">=</span> <span class="n">kriging_data</span><span class="p">[</span><span class="n">kriging_data</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>

    <span class="c1"># Get distances in max search radius</span>
    <span class="n">max_search_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">kriging_data</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_search_radius</span><span class="p">)</span>
    <span class="n">output_data</span> <span class="o">=</span> <span class="n">kriging_data</span><span class="p">[:</span><span class="n">max_search_pos</span><span class="p">]</span>

    <span class="c1"># check number of observations</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">number_of_neighbours</span><span class="p">:</span>
        <span class="n">output_data</span> <span class="o">=</span> <span class="n">kriging_data</span><span class="p">[:</span><span class="n">number_of_neighbours</span><span class="p">]</span>

    <span class="c1"># for each of prepared id prepare distances list with points&#39; weights for semivariogram calculation</span>

    <span class="n">points_vals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">points_and_vals_in_unknown_area</span> <span class="o">=</span> <span class="n">points_within_unknown_area</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">output_data</span><span class="p">:</span>
        <span class="n">areal_id</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">areal_value</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">known_area</span> <span class="o">=</span> <span class="n">points_within_known_areas</span><span class="p">[</span><span class="n">points_within_known_areas</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">areal_id</span><span class="p">]</span>
        <span class="n">known_area</span> <span class="o">=</span> <span class="n">known_area</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">points_in_known_area</span> <span class="o">=</span> <span class="n">known_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">vals_in_known_area</span> <span class="o">=</span> <span class="n">known_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Set distances array from each point of unknown area</span>
        <span class="n">merged_points_array</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">u_point</span> <span class="ow">in</span> <span class="n">points_and_vals_in_unknown_area</span><span class="p">:</span>
            <span class="n">u_point_dists</span> <span class="o">=</span> <span class="n">calc_point_to_point_distance</span><span class="p">(</span><span class="n">points_in_known_area</span><span class="p">,</span> <span class="p">[</span><span class="n">u_point</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">u_point_val</span> <span class="o">=</span> <span class="n">u_point</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">_merge_point_val_and_distances</span><span class="p">(</span><span class="n">u_point_val</span><span class="p">,</span> <span class="n">vals_in_known_area</span><span class="p">,</span> <span class="n">u_point_dists</span><span class="p">)</span>
            <span class="n">merged_points_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>

        <span class="n">total_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">known_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">generated_array</span> <span class="o">=</span> <span class="p">[</span><span class="n">areal_id</span><span class="p">,</span> <span class="n">areal_value</span><span class="p">,</span> <span class="n">merged_points_array</span><span class="p">,</span> <span class="n">total_val</span><span class="p">]</span>  <span class="c1"># [[id, value, [</span>
                                                                                   <span class="c1"># [unknown point value,</span>
                                                                                   <span class="c1">#     [known points values,</span>
                                                                                   <span class="c1">#      distances between points]],</span>
                                                                                   <span class="c1"># ...],</span>
                                                                                   <span class="c1">#  total known points value],</span>
                                                                                   <span class="c1"># [list of uknown point coords]]</span>
        <span class="n">points_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">generated_array</span><span class="p">)</span>

    <span class="n">output_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_vals</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">output_data</span><span class="p">,</span> <span class="n">points_within_unknown_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">Pyinterpolate</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Szymon Moliski.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>