
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>semivariance module &#8212; Pyinterpolate 0.2.3 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="kriging module" href="kriging.html" />
    <link rel="prev" title="distance module" href="distance.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="semivariance-module">
<h1>semivariance module<a class="headerlink" href="#semivariance-module" title="Permalink to this headline">¶</a></h1>
<p>Available classes and functions:</p>
<ul class="simple">
<li><p>ArealSemivariance: Class calculates semivariance of areas for Poisson Kriging (area to area and area to point),</p></li>
<li><p>RegularizedSemivariogram: Class performs deconvolution of semivariogram of areal data,</p></li>
<li><p>calculate_covariance: Function calculates covariance of a given set of points,</p></li>
<li><p>calculate_semivariance: Function calculates semivariance of a given set of points,</p></li>
<li><p>calculate_weighted_semivariance: Function calculates weighted semivariance,</p></li>
<li><p>calculate_directional_semivariogram: Function calculates semivariogram within specified ellipse,</p></li>
<li><p>build_variogram_point_cloud: Function creates OrderedDict with lags and variances between points within specific lag,</p></li>
<li><p>show_variogram_cloud: function shows boxplots of lags and squared differences between ponts’ values within specific lag,</p></li>
<li><p>calc_semivariance_from_pt_cloud: based on Point Cloud semivariogram is calculated,</p></li>
<li><p>remove_outliers: removes outliers from point cloud variogram,</p></li>
<li><p>TheoreticalSemivariogram: Class calculates theoretical semivariogram.</p></li>
</ul>
<section id="ArealSemivariance">
<h2><code class="docutils literal notranslate"><span class="pre">ArealSemivariance</span></code><a class="headerlink" href="#ArealSemivariance" title="Permalink to this headline">¶</a></h2>
<section id="Class-initialization">
<h3>Class initialization<a class="headerlink" href="#Class-initialization" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pyinterpolate</span><span class="o">.</span><span class="n">semivariance</span><span class="o">.</span><span class="n">ArealSemivariance</span><span class="p">(</span>
    <span class="n">areal_data</span><span class="p">,</span>
    <span class="n">areal_step_size</span><span class="p">,</span>
    <span class="n">max_areal_range</span><span class="p">,</span>
    <span class="n">areal_points_data</span><span class="p">,</span>
    <span class="n">weighted_semivariance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Class calculates semivariance of areas for Poisson Kriging (area to area and area to point).</p>
<p>INITIALIZATION PARAMS:</p>
<ul class="simple">
<li><p><strong>areal_data</strong>: (<em>numpy array</em> / <em>list</em>)</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">area_id</span><span class="p">,</span> <span class="n">area_geometry</span><span class="p">,</span> <span class="n">centroid</span> <span class="n">x</span><span class="p">,</span><span class="n">centroid</span> <span class="n">y</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>areal_step_size</strong>: (<em>float</em>) step size for search radius,</p></li>
<li><p><strong>max_areal_range</strong>: (<em>float</em>) max distance to perform distance and semivariance calculations,</p></li>
<li><p><strong>areal_points_data</strong>: (<em>numpy array</em> / <em>list</em>)</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>
    <span class="n">area_id</span><span class="p">,</span>
    <span class="p">[</span><span class="n">point_position_x</span><span class="p">,</span> <span class="n">point_position_y</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>weighted_semivariance</strong>: (<em>bool</em>) if <code class="docutils literal notranslate"><span class="pre">False</span></code> then each distance is treated equally when calculating theoretical semivariance; if <code class="docutils literal notranslate"><span class="pre">True</span></code> then semivariances closer to the point of origin have more weight,</p></li>
<li><p><strong>verbose</strong>: (<em>bool</em>) if <code class="docutils literal notranslate"><span class="pre">True</span></code> then all messages are printed, otherwise nothing.</p></li>
</ul>
</section>
<section id="Class-public-methods:">
<h3>Class public methods:<a class="headerlink" href="#Class-public-methods:" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><strong>regularize_semivariogram</strong>: Function calculates regularized point support semivariogram,</p></li>
<li><p><strong>show_semivariograms</strong>: Function shows semivariograms calculated by the class: Empirical semivariogram, Theoretical model, Inblock Semivariance, Within-block semivariogram, Between blocks semivariogram, Regularized output.</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="ArealSemivariance.regularize_semivariogram()">
<h3><code class="docutils literal notranslate"><span class="pre">ArealSemivariance.regularize_semivariogram()</span></code><a class="headerlink" href="#ArealSemivariance.regularize_semivariogram()" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ArealSemivariance</span><span class="o">.</span><span class="n">regularize_semivariogram</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">within_block_semivariogram</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">between_blocks_semivariogram</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">empirical_semivariance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">theoretical_semivariance_model</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>Function calculates regularized point support semivariogram in the form given in:</p>
<blockquote>
<div><p>Goovaerts P., Kriging and Semivariogram Deconvolution in the Presence of Irregular Geographical Units, Mathematical Geology 40(1), 101-128, 2008</p>
</div></blockquote>
<p>Function has the form:</p>
<div class="math notranslate nohighlight">
\[\gamma_{v(h)} = \gamma(v, v_h) - \gamma_{h}(v, v)\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\gamma_{v(h)}\)</span> - regularized semivariogram,</p></li>
<li><p><span class="math notranslate nohighlight">\(\gamma(v, v_h)\)</span> - semivariogram value between any two blocks separated by the distance <span class="math notranslate nohighlight">\(h\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(\gamma_{h}(v, v)\)</span> - arithmetical average of within-block semivariogram.</p></li>
</ul>
<p>INPUT:</p>
<ul class="simple">
<li><p><strong>within_block_semivariogram</strong>: (<em>numpy array</em>) mean semivariance between the blocks:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\gamma_{h}(v, v) = \frac{1}{2*N(h)} \sum^{N(h)}_{a=1} [\gamma(v\alpha, v\alpha) + \gamma(v\alpha+h, v\alpha+h)]\]</div>
<p>where:</p>
<p><span class="math notranslate nohighlight">\(\gamma(v\alpha, v\alpha)\)</span> and <span class="math notranslate nohighlight">\(\gamma(v\alpha+h, v\alpha+h)\)</span> are the inblock semivariances of block <span class="math notranslate nohighlight">\(\alpha\)</span> and block <span class="math notranslate nohighlight">\(\alpha+h\)</span> separated by the distance <span class="math notranslate nohighlight">\(h\)</span> weighted by the inblock population.</p>
<ul class="simple">
<li><p><strong>between_blocks_semivariogram</strong>: (<em>numpy array</em>) semivariance between all blocks calculated from the theoretical model,</p></li>
<li><p><strong>empirical_semivariance</strong>: (<em>numpy array</em>) empirical semivariance between area centroids, <code class="docutils literal notranslate"><span class="pre">default=None</span></code>, if <code class="docutils literal notranslate"><span class="pre">None</span></code> is provided then empirical semivariance is computed by the <code class="docutils literal notranslate"><span class="pre">_calculate_empirical_semivariance</span></code> method from area centroids,</p></li>
<li><p><strong>theoretical_semivariance_model</strong>: (<em>TheoreticalSemivariogram</em>) theoretical semivariance model from <code class="docutils literal notranslate"><span class="pre">TheoreticalSemivariance</span></code> class, default is <code class="docutils literal notranslate"><span class="pre">None</span></code>, if <code class="docutils literal notranslate"><span class="pre">None</span></code> is provided then theoretical model is derived from area centroids and empirical semivariance.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><strong>semivariance</strong>: (<code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) of lag, semivariance values and number of areas within lag where:</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">semivariance[0]</span> <span class="pre">=</span> <span class="pre">array</span> <span class="pre">of</span> <span class="pre">lags</span></code>;</p>
<p><code class="docutils literal notranslate"><span class="pre">semivariance[1]</span> <span class="pre">=</span> <span class="pre">array</span> <span class="pre">of</span> <span class="pre">lag's</span> <span class="pre">values</span></code>;</p>
<p><code class="docutils literal notranslate"><span class="pre">semivariance[2]</span> <span class="pre">=</span> <span class="pre">array</span> <span class="pre">of</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">points</span> <span class="pre">in</span> <span class="pre">each</span> <span class="pre">lag</span></code>.</p>
</section>
<hr class="docutils" />
<section id="ArealSemivariance.show_semivariograms()">
<h3><code class="docutils literal notranslate"><span class="pre">ArealSemivariance.show_semivariograms()</span></code><a class="headerlink" href="#ArealSemivariance.show_semivariograms()" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ArealSemivariance</span><span class="o">.</span><span class="n">show_semivariograms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>Function shows semivariograms calculated by the class: Empirical semivariogram, Theoretical model, Inblock Semivariance, Within-block semivariogram, Between blocks semivariogram, Regularized output.</p>
<hr class="docutils" />
</section>
</section>
<section id="RegularizedSemivariogram">
<h2><code class="docutils literal notranslate"><span class="pre">RegularizedSemivariogram</span></code><a class="headerlink" href="#RegularizedSemivariogram" title="Permalink to this headline">¶</a></h2>
<section id="id1">
<h3>Class initialization<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pyinterpolate</span><span class="o">.</span><span class="n">semivariance</span><span class="o">.</span><span class="n">RegularizedSemivariogram</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>Class performs deconvolution of semivariogram of areal data. Whole procedure is based on the iterative process described in:</p>
<blockquote>
<div><p>Goovaerts P., Kriging and Semivariogram Deconvolution in the Presence of Irregular Geographical Units, Mathematical Geology 40(1), 101-128, 2008</p>
</div></blockquote>
<p>Class works as follow:</p>
<ul class="simple">
<li><p>initialize your object (no parameters),</p></li>
<li><p>then use <code class="docutils literal notranslate"><span class="pre">fit()</span></code> method to build initial point support model,</p></li>
<li><p>then use <code class="docutils literal notranslate"><span class="pre">transform()</span></code> method to perform semivariogram regularization,</p></li>
<li><p>save semivariogram model with <code class="docutils literal notranslate"><span class="pre">export_model()</span></code> method.</p></li>
</ul>
</section>
<section id="id2">
<h3>Class public methods:<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><strong>fit</strong> - fits areal data and point support data into a model, initialize experimental semivariogram, theoretical semivariogram model, regularized point support model and deviation.</p></li>
<li><p><strong>transform</strong> - performs semivariogram regularization, which is an iterative process,</p></li>
<li><p><strong>export_regularized_model</strong> - Function exports final regularized model parameters into specified csv file.</p></li>
<li><p><strong>show_baseline_semivariograms</strong> - Function shows experimental semivariogram, initial theoretical semivariogram and initial regularized semivariogram after fit() operation.</p></li>
<li><p><strong>show_semivariograms</strong> - plots experimental semivariogram of area data, theoretical curve of area data, regularized model values and regularized model theoretical curve.</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="RegularizedSemivariogram.fit()">
<h3><code class="docutils literal notranslate"><span class="pre">RegularizedSemivariogram.fit()</span></code><a class="headerlink" href="#RegularizedSemivariogram.fit()" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">RegularizedSemivariogram</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">areal_data</span><span class="p">,</span>
                             <span class="n">areal_step_size</span><span class="p">,</span>
                             <span class="n">max_areal_range</span><span class="p">,</span>
                             <span class="n">point_support_data</span><span class="p">,</span>
                             <span class="n">weighted_lags</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">store_models</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Function fits area and point support data to the initial regularized models.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><strong>areal_data</strong>: (<em>numpy array</em>) areal data prepared with the function <code class="docutils literal notranslate"><span class="pre">prepare_areal_shapefile()</span></code>, where data is a <code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>in the form:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">area_id</span><span class="p">,</span> <span class="n">area_geometry</span><span class="p">,</span> <span class="n">centroid</span> <span class="n">x</span><span class="p">,</span> <span class="n">centroid</span> <span class="n">y</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>areal_step_size</strong>: (<em>float</em>) step size between each lag, usually it is a half of distance between lags,</p></li>
<li><p><strong>max_areal_range</strong>: (<em>float</em>) max distance to perform distance and semivariance calculations,</p></li>
<li><p><strong>point_support_data</strong>: (<em>numpy array</em>) point support data prepared with the function <code class="docutils literal notranslate"><span class="pre">get_points_within_area()</span></code>, where data is a <code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> in the form:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>
    <span class="n">area_id</span><span class="p">,</span>
    <span class="p">[</span><span class="n">point_position_x</span><span class="p">,</span> <span class="n">point_position_y</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>weighted_lags</strong>: (<em>bool</em>) lags weighted by number of points; if <code class="docutils literal notranslate"><span class="pre">True</span></code> then during semivariogram fitting error of each model is weighted by number of points for each lag. In practice it means that more reliable data (lags) have larger weights and semivariogram is modeled to better fit to those lags,</p></li>
<li><p><strong>store_models</strong>: (<em>bool</em>) if <code class="docutils literal notranslate"><span class="pre">True</span></code> then experimental, regularized and theoretical models are stored in lists after each iteration. It is important for a debugging process.</p></li>
</ul>
<p>OUTPUT:</p>
<p>None, class is updating its internal parameters. Usually after fitting you should perform regularization with <code class="docutils literal notranslate"><span class="pre">transform()</span></code> method.</p>
</section>
<hr class="docutils" />
<section id="RegularizedSemivariogram.transform()">
<h3><code class="docutils literal notranslate"><span class="pre">RegularizedSemivariogram.transform()</span></code><a class="headerlink" href="#RegularizedSemivariogram.transform()" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">RegularizedSemivariogram</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                   <span class="n">max_iters</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
                                   <span class="n">min_deviation_ratio</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                                   <span class="n">min_diff_decrease</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                                   <span class="n">min_diff_decrease_reps</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Function transofrms fitted data and performs semivariogram regularization iterative procedure.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><strong>max_iters</strong>: (<em>int</em>) maximum number of iterations,</p></li>
<li><p><strong>min_deviation_ratio</strong>: (<em>float</em>) minimum ratio between deviation and initial deviation (D(i) / D(0)) below each algorithm is stopped,</p></li>
<li><p><strong>min_diff_decrease</strong>: (<em>float</em>) minimum absolute difference between new and optimal deviation divided by optimal deviation: ABS(D(i) - D(opt)) / D(opt). If it is recorded <code class="docutils literal notranslate"><span class="pre">n</span></code> times (controled by the <code class="docutils literal notranslate"><span class="pre">min_diff_d_stat_reps</span></code> param) then algorithm is stopped,</p></li>
<li><p><strong>min_diff_decrease_reps</strong>: (<em>int</em>) number of iterations when algorithm is stopped if condition <code class="docutils literal notranslate"><span class="pre">min_diff_d_stat</span></code> is fulfilled.</p></li>
</ul>
<p>OUTPUT:</p>
<p>None, class is updating its internal parameters. Usually after transforming you should export your theoretical model with <code class="docutils literal notranslate"><span class="pre">export_regularized_model()</span></code> method.</p>
</section>
<hr class="docutils" />
<section id="RegularizedSemivariogram.export_regularized_model()">
<h3><code class="docutils literal notranslate"><span class="pre">RegularizedSemivariogram.export_regularized_model()</span></code><a class="headerlink" href="#RegularizedSemivariogram.export_regularized_model()" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">RegularizedSemivariogram</span><span class="o">.</span><span class="n">export_regularized_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                  <span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>Function exports final regularized model parameters into specified csv file.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><strong>filename</strong>: (<em>str</em>) filename for model parameters (nugget, sill, range, model type).</p></li>
</ul>
<p>OUTPUT:</p>
<p>Method saves regularized model into csv file.</p>
</section>
<hr class="docutils" />
<section id="RegularizedSemivariogram.show_baseline_semivariograms()">
<h3><code class="docutils literal notranslate"><span class="pre">RegularizedSemivariogram.show_baseline_semivariograms()</span></code><a class="headerlink" href="#RegularizedSemivariogram.show_baseline_semivariograms()" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">RegularizedSemivariogram</span><span class="o">.</span><span class="n">show_baseline_semivariograms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>Function shows experimental semivariogram, initial theoretical semivariogram and initial regularized semivariogram after <code class="docutils literal notranslate"><span class="pre">fit()</span></code> operation.</p>
</section>
<hr class="docutils" />
<section id="RegularizedSemivariogram.show_semivariograms()">
<h3><code class="docutils literal notranslate"><span class="pre">RegularizedSemivariogram.show_semivariograms()</span></code><a class="headerlink" href="#RegularizedSemivariogram.show_semivariograms()" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">RegularizedSemivariogram</span><span class="o">.</span><span class="n">show_semivariograms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>Function shows experimental semivariogram, theoretical semivariogram and regularized semivariogram after semivariogram regularization with <code class="docutils literal notranslate"><span class="pre">transform()</span></code> method.</p>
<hr class="docutils" />
</section>
</section>
<section id="calculate_covariance()">
<h2><code class="docutils literal notranslate"><span class="pre">calculate_covariance()</span></code><a class="headerlink" href="#calculate_covariance()" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pyinterpolate</span><span class="o">.</span><span class="n">semivariance</span><span class="o">.</span><span class="n">calculate_covariance</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">step_size</span><span class="p">,</span>
    <span class="n">max_range</span><span class="p">)</span>
</pre></div>
</div>
<p>Function calculates covariance of a given set of points.</p>
<p>Equation for calculation is:</p>
<div class="math notranslate nohighlight">
\[covariance = \frac{1}{N} * \sum_{i=1}^{N} [z(x_{i} + h) * z(x_{i})] - u^{2}\]</div>
<p>where:</p>
<p><span class="math notranslate nohighlight">\(N\)</span> - number of observation pairs,</p>
<p><span class="math notranslate nohighlight">\(h\)</span> - distance (lag),</p>
<p><span class="math notranslate nohighlight">\(z(x_{i})\)</span> - value at location <span class="math notranslate nohighlight">\(z_{i}\)</span>,</p>
<p><span class="math notranslate nohighlight">\((x_{i} + h)\)</span> - location at a distance <span class="math notranslate nohighlight">\(h\)</span> from <span class="math notranslate nohighlight">\(x_{i}\)</span>,</p>
<p><span class="math notranslate nohighlight">\(u\)</span> - mean of observations at a given lag distance.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><strong>data</strong>: (<em>numpy array</em>) coordinates and their values,</p></li>
<li><p><strong>step_size</strong>: (<em>float</em>) distance between lags within each points are included in the calculations,</p></li>
<li><p><strong>max_range</strong>: (<em>float</em>) maximum range of analysis.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>(<code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) covariance - array of pair of lag and covariance values where:</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">covariance[0]</span> <span class="pre">=</span> <span class="pre">array</span> <span class="pre">of</span> <span class="pre">lags</span></code>;</p>
<p><code class="docutils literal notranslate"><span class="pre">covariance[1]</span> <span class="pre">=</span> <span class="pre">array</span> <span class="pre">of</span> <span class="pre">lag's</span> <span class="pre">values</span></code>;</p>
<p><code class="docutils literal notranslate"><span class="pre">covariance[2]</span> <span class="pre">=</span> <span class="pre">array</span> <span class="pre">of</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">points</span> <span class="pre">in</span> <span class="pre">each</span> <span class="pre">lag</span></code>.</p>
<hr class="docutils" />
</section>
<section id="calculate_semivariance()">
<h2><code class="docutils literal notranslate"><span class="pre">calculate_semivariance()</span></code><a class="headerlink" href="#calculate_semivariance()" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pyinterpolate</span><span class="o">.</span><span class="n">semivariance</span><span class="o">.</span><span class="n">calculate_semivariance</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">step_size</span><span class="p">,</span>
    <span class="n">max_range</span><span class="p">)</span>
</pre></div>
</div>
<p>Function calculates semivariance of a given set of points.</p>
<p>Equation for calculation is:</p>
<div class="math notranslate nohighlight">
\[semivariance = \frac{1}{2N} * \sum_{i=1}^{N} [z(x_{i} + h) - z(x_{i})]^{2}\]</div>
<p>where:</p>
<p><span class="math notranslate nohighlight">\(N\)</span> - number of observation pairs,</p>
<p><span class="math notranslate nohighlight">\(h\)</span> - distance (lag),</p>
<p><span class="math notranslate nohighlight">\(z(x_{i})\)</span> - value at location <span class="math notranslate nohighlight">\(z_{i}\)</span>,</p>
<p><span class="math notranslate nohighlight">\((x_{i} + h)\)</span> - location at a distance <span class="math notranslate nohighlight">\(h\)</span> from <span class="math notranslate nohighlight">\(x_{i}\)</span>,</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><strong>data</strong>: (<em>numpy array</em>) coordinates and their values,</p></li>
<li><p><strong>step_size</strong>: (<em>float</em>) distance between lags within each points are included in the calculations,</p></li>
<li><p><strong>max_range</strong>: (<em>float</em>) maximum range of analysis.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>(<code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) semivariance - array of pair of lag and semivariance values where:</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">semivariance[0]</span> <span class="pre">=</span> <span class="pre">array</span> <span class="pre">of</span> <span class="pre">lags</span></code>;</p>
<p><code class="docutils literal notranslate"><span class="pre">semivariance[1]</span> <span class="pre">=</span> <span class="pre">array</span> <span class="pre">of</span> <span class="pre">lag's</span> <span class="pre">values</span></code>;</p>
<p><code class="docutils literal notranslate"><span class="pre">semivariance[2]</span> <span class="pre">=</span> <span class="pre">array</span> <span class="pre">of</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">points</span> <span class="pre">in</span> <span class="pre">each</span> <span class="pre">lag</span></code>.</p>
<hr class="docutils" />
</section>
<section id="calculate_weighted_semivariance()">
<h2><code class="docutils literal notranslate"><span class="pre">calculate_weighted_semivariance()</span></code><a class="headerlink" href="#calculate_weighted_semivariance()" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pyinterpolate</span><span class="o">.</span><span class="n">semivariance</span><span class="o">.</span><span class="n">calculate_weighted_semivariance</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">step_size</span><span class="p">,</span>
    <span class="n">max_range</span><span class="p">)</span>
</pre></div>
</div>
<p>Function calculates weighted semivariance following <em>Monestiez et al.</em>:</p>
<blockquote>
<div><ol class="upperalpha simple">
<li><p>Monestiez P, Dubroca L, Bonnin E, Durbec JP, Guinet C: Comparison of model based geostatistical methods in ecology: application to fin whale spatial distribution in northwestern Mediterranean Sea. In Geostatistics Banff 2004 Volume 2. Edited by: Leuangthong O, Deutsch CV. Dordrecht, The Netherlands, Kluwer Academic Publishers; 2005:777-786.</p></li>
</ol>
</div></blockquote>
<blockquote>
<div><ol class="upperalpha simple" start="2">
<li><p>Monestiez P, Dubroca L, Bonnin E, Durbec JP, Guinet C: Geostatistical modelling of spatial distribution of Balenoptera physalus in the northwestern Mediterranean Sea from sparse count data and heterogeneous observation efforts. Ecological Modelling 2006 in press.</p></li>
</ol>
</div></blockquote>
<p>Equation for calculation is:</p>
<div class="math notranslate nohighlight">
\[s(h) = \frac{1}{2*\sum_{a=1}^{N(h)} c_{a}} * \sum_{a=1}^{N(h)} c_{a}*(z(u_{a}) - z(u_{a} + h))^2 - m'\]</div>
<p>where:</p>
<div class="math notranslate nohighlight">
\[c_{a} = \frac{n(u_{a}) * n(u_{a} + h)}{n(u_{a}) + n(u_{a} + h)}\]</div>
<p>where:</p>
<p><span class="math notranslate nohighlight">\(s(h)\)</span> Semivariogram of the risk,</p>
<p><span class="math notranslate nohighlight">\(n(u_{a})\)</span> - size of the population at risk in the unit a,</p>
<p><span class="math notranslate nohighlight">\(z(u_{a})\)</span> - mortality rate at the unit a,</p>
<p><span class="math notranslate nohighlight">\(u_{a} + h\)</span> - area at the distance (h) from the analyzed area,</p>
<p><span class="math notranslate nohighlight">\(m'\)</span> - population weighted mean of rates.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><strong>data</strong>: (<em>numpy array</em>) coordinates and their values and weights:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">coordinate</span> <span class="n">x</span><span class="p">,</span> <span class="n">coordinate</span> <span class="n">y</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">weight</span><span class="p">]</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>step_size</strong>: (<em>float</em>) distance between lags within each points are included in the calculations,</p></li>
<li><p><strong>max_range</strong>: (<em>float</em>) maximum range of analysis.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>(<code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) semivariance - array of pair of lag and semivariance values where:</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">semivariance[0]</span> <span class="pre">=</span> <span class="pre">array</span> <span class="pre">of</span> <span class="pre">lags</span></code>;</p>
<p><code class="docutils literal notranslate"><span class="pre">semivariance[1]</span> <span class="pre">=</span> <span class="pre">array</span> <span class="pre">of</span> <span class="pre">lag's</span> <span class="pre">values</span></code>;</p>
<p><code class="docutils literal notranslate"><span class="pre">semivariance[2]</span> <span class="pre">=</span> <span class="pre">array</span> <span class="pre">of</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">points</span> <span class="pre">in</span> <span class="pre">each</span> <span class="pre">lag</span></code>.</p>
<hr class="docutils" />
</section>
<section id="calculate_directional_semivariogram()">
<h2><code class="docutils literal notranslate"><span class="pre">calculate_directional_semivariogram()</span></code><a class="headerlink" href="#calculate_directional_semivariogram()" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pyinterpolate</span><span class="o">.</span><span class="n">semivariance</span><span class="o">.</span><span class="n">calculate_directional_semivariogram</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">step_size</span><span class="p">,</span>
    <span class="n">max_range</span><span class="p">,</span>
    <span class="n">direction</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>Function calculates directional semivariogram of points. Semivariance is calculated as:</p>
<div class="math notranslate nohighlight">
\[semivariance = \frac{1}{2N} * \sum_{i=1}^{N} [z(x_{i} + h) - z(x_{i})]^{2}\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(N\)</span> - number of observation pairs,</p></li>
<li><p><span class="math notranslate nohighlight">\(h\)</span> - distance (lag),</p></li>
<li><p><span class="math notranslate nohighlight">\(z(x_{i})\)</span> - value at location <span class="math notranslate nohighlight">\(z_{i}\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\((x_{i} + h)\)</span> - location at a distance <span class="math notranslate nohighlight">\(h\)</span> from <span class="math notranslate nohighlight">\(x_{i}\)</span>.</p></li>
</ul>
<p>INPUT:</p>
<ul class="simple">
<li><p><strong>data</strong>: (<a href="#id3"><span class="problematic" id="id4">*</span></a>numpy array8) coordinates and their values,</p></li>
<li><p><strong>step_size</strong>: (<em>float</em>) distance between lags within each points are included in the calculations,</p></li>
<li><p><strong>max_range</strong>: (<em>float</em>) maximum range of analysis,</p></li>
<li><p><strong>direction</strong>: (<em>float</em>) direction of semivariogram, values from 0 to 360 degrees:</p></li>
</ul>
<p>– 0 or 180: is NS direction,</p>
<p>– 90 or 270 is EW direction,</p>
<p>– 30 or 210 is NE-SW direction,</p>
<p>– 120 or 300 is NW-SE direction,</p>
<ul class="simple">
<li><p>tolerance: (float) value in range (0-1) normalized to [0 : 0.5] to select tolerance of semivariogram. If tolerance is 0 then points must be placed at a single line with beginning in the origin of coordinate system and angle given by y axis and direction parameter. If tolerance is greater than 0 then semivariance is estimated from elliptical area with major axis with the same direction as the line for 0 tolerance and minor axis of a size:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[(tolerance * step\_size)\]</div>
<p>and major axis (pointed in NS direction):</p>
<div class="math notranslate nohighlight">
\[((1 - tolerance) * step\_size)\]</div>
<p>and baseline point at a center of ellipse. Tolerance == 1 (normalized to 0.5) creates omnidirectional semivariogram.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>(<em>numpy array</em>) <strong>semivariance</strong> - array of pair of lag and semivariance values where:</p></li>
</ul>
<p>– semivariance[0] = array of lags;</p>
<p>– semivariance[1] = array of lag’s values;</p>
<p>– semivariance[2] = array of number of points in each lag.</p>
<hr class="docutils" />
</section>
<section id="build_variogram_point_cloud()">
<h2><code class="docutils literal notranslate"><span class="pre">build_variogram_point_cloud()</span></code><a class="headerlink" href="#build_variogram_point_cloud()" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pyinterpolate</span><span class="o">.</span><span class="n">semivariance</span><span class="o">.</span><span class="n">build_variogram_point_cloud</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">step_size</span><span class="p">,</span>
    <span class="n">max_range</span><span class="p">)</span>
</pre></div>
</div>
<p>Function calculates variogram point cloud of a given set of points for a given set of distances. Variogram is calculated as a squared difference of each point against other point within range specified by step_size parameter.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><strong>data</strong>: (<em>numpy array</em>) coordinates and their values and weights:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">coordinate</span> <span class="n">x</span><span class="p">,</span> <span class="n">coordinate</span> <span class="n">y</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">weight</span><span class="p">]</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>step_size</strong>: (<em>float</em>) distance between lags within each points are included in the calculations,</p></li>
<li><p><strong>max_range</strong>: (<em>float</em>) maximum range of analysis.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>(<em>OrderedDict</em>) variogram_cloud - dict with pairs {lag: list of squared differences}.</p></li>
</ul>
<hr class="docutils" />
</section>
<section id="show_variogram_cloud()">
<h2><code class="docutils literal notranslate"><span class="pre">show_variogram_cloud()</span></code><a class="headerlink" href="#show_variogram_cloud()" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pyinterpolate</span><span class="o">.</span><span class="n">semivariance</span><span class="o">.</span><span class="n">show_variogram_cloud</span><span class="p">(</span>
    <span class="n">variogram_cloud</span><span class="p">,</span>
    <span class="n">figsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>Function shows boxplots of variogram lags. It is especially useful when you want to check outliers in your dataset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><strong>variogram_cloud</strong>: (<em>OrderedDict</em>) lags and halved squared differences between points,</p></li>
<li><p><strong>figsize</strong>: (<em>tuple</em>), default is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
<hr class="docutils" />
</section>
<section id="calc_semivariance_from_pt_cloud()">
<h2><code class="docutils literal notranslate"><span class="pre">calc_semivariance_from_pt_cloud()</span></code><a class="headerlink" href="#calc_semivariance_from_pt_cloud()" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pyinterpolate</span><span class="o">.</span><span class="n">semivariance</span><span class="o">.</span><span class="n">calc_semivariance_from_pt_cloud</span><span class="p">(</span>
    <span class="n">pt_cloud_dict</span><span class="p">)</span>
</pre></div>
</div>
<p>Function calculates experimental semivariogram from point cloud variogram.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><strong>pt_cloud_dict</strong>: (<em>OrderedDict</em>) {lag: [values]}.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>(<em>numpy array</em>) [lag, semivariance, number of points].</p></li>
</ul>
<hr class="docutils" />
</section>
<section id="remove_outliers()">
<h2><code class="docutils literal notranslate"><span class="pre">remove_outliers()</span></code><a class="headerlink" href="#remove_outliers()" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pyinterpolate</span><span class="o">.</span><span class="n">semivariance</span><span class="o">.</span><span class="n">remove_outliers</span><span class="p">(</span><span class="n">data_dict</span><span class="p">,</span>
                                           <span class="n">exclude_part</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span>
                                           <span class="n">weight</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Function removes outliers from the variogram point cloud for each lag and returns dict without extreme values from the top, bottom or both parts of the variogram point cloud for a given lag. Algorithm uses quartiles to remove outliers:</p>
<ol class="arabic">
<li><div class="math notranslate nohighlight">
\[BottomOutlier &lt; Q1 - w*(Q3-Q1)\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[Q3 + w*(Q3-Q1) &lt; TopOutlier\]</div>
</li>
</ol>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Q1\)</span> - 1st quantile (25%)</p></li>
<li><p><span class="math notranslate nohighlight">\(Q3\)</span> - 3rd quantile (75%)</p></li>
<li><p><span class="math notranslate nohighlight">\(w\)</span> - weight associated with the algorithm, larger weight =&gt; less number of values treated as an outlier.</p></li>
</ul>
<p>INPUT:</p>
<ul class="simple">
<li><p><strong>data_dict</strong>: (<em>OrderedDict</em>) with {lag: list of values},</p></li>
<li><p><strong>exclude_part</strong>: (<em>str</em>) default = <code class="docutils literal notranslate"><span class="pre">'top'</span></code>, available <code class="docutils literal notranslate"><span class="pre">'top'</span></code>, <code class="docutils literal notranslate"><span class="pre">'both'</span></code> or <code class="docutils literal notranslate"><span class="pre">'bottom'</span></code> - part of the variogram point cloud which is excluded from a given lag.</p></li>
<li><p><strong>weight</strong>: (<em>float</em>) default=1.5, affects number of values which are removed.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>(<em>OrderedDict</em>) {lag: [variances between point pairs within a given lag]}</p></li>
</ul>
<hr class="docutils" />
</section>
<section id="TheoreticalSemivariogram">
<h2><code class="docutils literal notranslate"><span class="pre">TheoreticalSemivariogram</span></code><a class="headerlink" href="#TheoreticalSemivariogram" title="Permalink to this headline">¶</a></h2>
<section id="id5">
<h3>Class initialization<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pyinterpolate</span><span class="o">.</span><span class="n">semivariance</span><span class="o">.</span><span class="n">TheoreticalSemivariogram</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">points_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">empirical_semivariance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Class calculates theoretical semivariogram.</p>
<p>Available theoretical models:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>- spherical_model(distance, nugget, sill, semivar_range)
- gaussian_model(distance, nugget, sill, semivar_range)
- exponential_model(distance, nugget, sill, semivar_range)
- linear_model(distance, nugget, sill, semivar_range)
</pre></div>
</div>
<p>INITIALIZATION PARAMS:</p>
<ul class="simple">
<li><p><strong>points_array</strong>: (<em>numpy array</em>) analysed points where the last column is representing values, typically x, y, value,</p></li>
<li><p><strong>empirical_semivariance</strong>: (<em>numpy array</em>) semivariance where first row of array represents lags and the second row represents semivariance’s values for given lag.</p></li>
</ul>
</section>
<section id="id6">
<h3>Class public methods:<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><strong>fit_semivariance</strong>: Method fits experimental points into chosen semivariance model type,</p></li>
<li><p><strong>find_optimal_model</strong>: Method fits experimental points into all available models and choose one with the lowest error,</p></li>
<li><p><strong>export_model</strong>: Function exports semivariance model to the csv file,</p></li>
<li><p><strong>import_model</strong>: Function imports semivariance model and updates it’s parameters,</p></li>
<li><p><strong>export_semivariance</strong>: Method exports theoretical semivariance and experimental semivariance to csv file,</p></li>
<li><p><strong>show_experimental_semivariogram</strong>: Function shows experimental semivariogram of a given model,</p></li>
<li><p><strong>show_semivariogram</strong>: Function shows experimental and theoretical semivariogram in one plot.</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="TheoreticalSemivariogram.fit_semivariance()">
<h3><code class="docutils literal notranslate"><span class="pre">TheoreticalSemivariogram.fit_semivariance()</span></code><a class="headerlink" href="#TheoreticalSemivariogram.fit_semivariance()" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">TheoreticalSemivariogram</span><span class="o">.</span><span class="n">fit_semivariance</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">model_type</span><span class="p">,</span>
    <span class="n">number_of_ranges</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
<p>Method fits experimental points into chosen semivariance model type.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><strong>model_type</strong>: (<em>str</em>) ‘exponential’, ‘gaussian’, ‘linear’, ‘spherical’,</p></li>
<li><p><strong>number_of_ranges</strong>: (<em>int</em>) deafult = 16. Used to create an array of equidistant ranges between minimal range of empirical semivariance and maximum range of empirical semivariance.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>(model_type, model parameters)</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="TheoreticalSemivariogram.find_optimal_model()">
<h3><code class="docutils literal notranslate"><span class="pre">TheoreticalSemivariogram.find_optimal_model()</span></code><a class="headerlink" href="#TheoreticalSemivariogram.find_optimal_model()" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">TheoreticalSemivariogram</span><span class="o">.</span><span class="n">find_optimal_model</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">weighted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">number_of_ranges</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
<p>Method fits experimental points into all available models and choose one with the lowest error.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><strong>weighted</strong>: (<em>bool</em>) default=<code class="docutils literal notranslate"><span class="pre">False</span></code>. If <code class="docutils literal notranslate"><span class="pre">True</span></code> then each lag is weighted by:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{\sqrt{N(h)}}{\gamma_{experimental}(h)}\]</div>
<p>where:</p>
<p><span class="math notranslate nohighlight">\(N(h)\)</span> - number of point pairs in a given range,</p>
<p><span class="math notranslate nohighlight">\(\gamma_{experimental}(h)\)</span> - value of experimental semivariogram for <span class="math notranslate nohighlight">\(h\)</span>. - <strong>number_of_ranges</strong>: (<em>int</em>) default=16. Used to create an array of equidistant ranges between minimal range of empirical semivariance and maximum range of empirical semivariance.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>model_type</p></li>
</ul>
<p>Function updates class parameters with model properties.</p>
</section>
<hr class="docutils" />
<section id="TheoreticalSemivariogram.export_model()">
<h3><code class="docutils literal notranslate"><span class="pre">TheoreticalSemivariogram.export_model()</span></code><a class="headerlink" href="#TheoreticalSemivariogram.export_model()" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">TheoreticalSemivariogram</span><span class="o">.</span><span class="n">export_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>Function exports semivariance model to the csv file. Columns of csv file are: name, nugget, sill, range, model_error.</p>
</section>
<hr class="docutils" />
<section id="TheoreticalSemivariogram.import_model()">
<h3><code class="docutils literal notranslate"><span class="pre">TheoreticalSemivariogram.import_model()</span></code><a class="headerlink" href="#TheoreticalSemivariogram.import_model()" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">TheoreticalSemivariogram</span><span class="o">.</span><span class="n">import_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>Function imports semivariance model and updates its parameters (model name, nugget, sill, range, model_error).</p>
</section>
<hr class="docutils" />
<section id="TheoreticalSemivariogram.export_semivariance()">
<h3><code class="docutils literal notranslate"><span class="pre">TheoreticalSemivariogram.export_semivariance()</span></code><a class="headerlink" href="#TheoreticalSemivariogram.export_semivariance()" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">TheoreticalSemivariogram</span><span class="o">.</span><span class="n">export_semivariance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>Function exports semivariance data into csv file. Exported data has three columns: <code class="docutils literal notranslate"><span class="pre">lags</span></code>, <code class="docutils literal notranslate"><span class="pre">experimental</span></code>, <code class="docutils literal notranslate"><span class="pre">theoretical</span></code> where theoretical values are calculated from the fitted model and lags given by experimental semivariogram.</p>
</section>
<hr class="docutils" />
<section id="TheoreticalSemivariogram.show_experimental_semivariogram()">
<h3><code class="docutils literal notranslate"><span class="pre">TheoreticalSemivariogram.show_experimental_semivariogram()</span></code><a class="headerlink" href="#TheoreticalSemivariogram.show_experimental_semivariogram()" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">TheoreticalSemivariogram</span><span class="o">.</span><span class="n">show_experimental_semivariogram</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>Function shows experimental semivariogram of a given model.</p>
</section>
<hr class="docutils" />
<section id="TheoreticalSemivariogram.show_semivariogram()">
<h3><code class="docutils literal notranslate"><span class="pre">TheoreticalSemivariogram.show_semivariogram()</span></code><a class="headerlink" href="#TheoreticalSemivariogram.show_semivariogram()" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">TheoreticalSemivariogram</span><span class="o">.</span><span class="n">show_semivariogram</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>Function shows experimental and theoretical semivariogram in one plot.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Pyinterpolate</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../setup.html">Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../code_documentation.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../algorithms.html">Algorithms Explained</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribution.html">Contribution to Pyinterpolate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../code_documentation.html">Documentation</a><ul>
      <li>Previous: <a href="distance.html" title="previous chapter">distance module</a></li>
      <li>Next: <a href="kriging.html" title="next chapter">kriging module</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Szymon Moliński.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/code_documentation/semivariance.ipynb.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>