{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# transform module\n",
    "\n",
    "Available methods:\n",
    "\n",
    "- check_points_within_ellipse: checks if points are grouped within specified ellipse for directional semivariograms,\n",
    "- get_centroids: gets position x and y of polygon centroid,\n",
    "- prepare_kriging_data: prepares data for kriging - array of point position, value and distance to an unknown point,\n",
    "- prepare_poisson_kriging_data: prepares data for centroid based Poisson Kriging,\n",
    "- prepare_ata_data: prepares data for Area to Area Poisson Kriging,\n",
    "- prepare_atp_data: prepares data for Area to Point Poisson Kriging,\n",
    "- select_values_in_range: selects set of values which are greater than (lag - step size) and lesser than (lag + step size),\n",
    "- set_areal_weights: prepares array for weighted semivariance calculation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "***"
   ]
  },
  {
   "cell_type": "markdown",
   "source": [
    "## ```check_points_within_ellipse()```\n",
    "\n",
    "```python\n",
    "pyinterpolate.transform.check_points_within_ellipse(\n",
    "    origin_point,\n",
    "    other_points,\n",
    "    step_size,\n",
    "    last_step_size,\n",
    "    angle,\n",
    "    tolerance\n",
    ")\n",
    "```\n",
    "\n",
    "Function checks which points from other points are within point range described as an ellipse with\n",
    "center in an `origin_point`, semi-major axis of length `step_size` and semi-minor axis of length\n",
    "`step_size * tolerance` and angle of semi-major axis calculated as `angle` of direction from\n",
    "NS (0 radian angle) axis of a dataset.\n",
    "\n",
    "INPUT:\n",
    "\n",
    "- **origin_point**: (*numpy array*) single point coordinates,\n",
    "- **other_points**: (*numpy array*),\n",
    "- **step_size**: (*float*) current distance between lags within each points are included in the calculations,\n",
    "- **last_step_size**: (*float*) last distance between lags within each points are included in the calculations,\n",
    "- **angle**: (*float*) direction of semivariogram, in radians. Angle is rotated by PI/2 rad.\n",
    "- **tolerance**: (*float*) value in range 0-1 normalized to `[0 : 0.5]` to select tolerance of semivariogram. If\n",
    "tolerance is 0 then points must be placed at a single line with beginning in the origin of coordinate\n",
    "system and angle given by y axis and direction parameter. If tolerance is greater than 0 then semivariance\n",
    "is estimated from elliptical area with major axis with the same direction as the line for 0 tolerance\n",
    "and minor axis of a size:\n",
    "\n",
    "$$(tolerance * step\\_size)$$\n",
    "\n",
    "and major axis (pointed in NS direction):\n",
    "\n",
    "$$((1 - tolerance) * step\\_size)$$\n",
    "\n",
    "and baseline point at a center of ellipse. `tolerance == 1` creates omnidirectional semivariogram.\n",
    "\n",
    "#### ROTATED ELLIPSE EQUATION:\n",
    "\n",
    "$$part_a = [cos(A) * (x - h) + sin(A) * (y - k)]^2$$\n",
    "\n",
    "$$part_b = [sin(A) * (x - h) + cos(A) * (y - k)]^2$$\n",
    "\n",
    "and if:\n",
    "\n",
    "$$\\frac{part_a}{r_x^2} + \\frac{part_b}{r_y^2} <= 1$$\n",
    "\n",
    "then point is inside ellipse.\n",
    "\n",
    "OUTPUT:\n",
    "\n",
    "(*numpy array*) boolean array of **points within ellipse with center in origin point**."
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   }
  },
  {
   "cell_type": "markdown",
   "source": [
    "***"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   }
  },
  {
   "cell_type": "markdown",
   "source": [
    "## ```get_centroids()```\n",
    "\n",
    "```python\n",
    "pyinterpolate.transform.get_centroids(polygon)\n",
    "```\n",
    "\n",
    "Function gets position x and y of polygon centroid.\n",
    "\n",
    "\n",
    "INPUT:\n",
    "\n",
    "- **polygon**: (_shapely Polygon_).\n",
    "\n",
    "\n",
    "OUTPUT:\n",
    "\n",
    "- (*tuple*) centroid position (x, y) for a given area."
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   }
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "***"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ```prepare_kriging_data()```\n",
    "\n",
    "```python\n",
    "pyinterpolate.transform.prepare_kriging_data(\n",
    "    unknown_position,\n",
    "    data_array,\n",
    "    number_of_neighbours=10)\n",
    "```\n",
    "\n",
    "Function prepares data for kriging - array of point position, value and distance to an unknown point.\n",
    "\n",
    "\n",
    "INPUT:\n",
    "\n",
    "- **unknown_position**: (_numpy array_) position of unknown value,\n",
    "- **data_array**: (_numpy array_) known positions and their values,\n",
    "- **number_of_neighbours**: (_int_) number of the closest locations to the unknown position.\n",
    "\n",
    "\n",
    "OUTPUT:\n",
    "\n",
    "- (```numpy array```) dataset with position, value and distance to the unknown point:\n",
    "\n",
    "```python\n",
    "[\n",
    "    [x, y, value, distance to unknown position],\n",
    "    [...]\n",
    "]\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "***"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ```prepare_poisson_kriging_data()```\n",
    "\n",
    "```python\n",
    "pyinterpolate.transform.prepare_poisson_kriging_data(\n",
    "    unknown_area,\n",
    "    points_within_unknown_area,\n",
    "    known_areas,\n",
    "    points_within_known_areas,\n",
    "    number_of_neighbours,\n",
    "    max_search_radius,\n",
    "    weighted=False)\n",
    "```\n",
    "\n",
    "Function prepares data for centroid based Poisson Kriging.\n",
    "\n",
    "\n",
    "INPUT:\n",
    "\n",
    "- **unknown_area**: (_numpy array_) unknown area in the form: \n",
    "\n",
    "```python\n",
    "[area_id, polygon, centroid x, centroid y]\n",
    "```\n",
    "- **points_within_unknown_area**: (_numpy array_) points and their values within the given area:\n",
    "\n",
    "```python\n",
    "[\n",
    "    area_id,\n",
    "    [point_position_x, point_position_y, value]\n",
    "]\n",
    "```\n",
    "- **known_areas**: (_numpy array_) known areas in the form:\n",
    "\n",
    "```python\n",
    "[area_id, polygon, centroid x, centroid y, aggregated value]\n",
    "```\n",
    "- **points_within_known_areas**: (_numpy array_) points and their values within the given area:\n",
    "\n",
    "```python\n",
    "[\n",
    "    area_id,\n",
    "    [point_position_x, point_position_y, value]\n",
    "]\n",
    "```\n",
    "- **number_of_neighbours**: (_int_) minimum number of neighbours to include in the algorithm,\n",
    "- **max_search_radius**: (_float_) maximum search radius (if number of neighbours within this search radius is smaller than ```number_of_neighbours``` parameter then additional neighbours are included up to the minimum number of neighbors),\n",
    "- **weighted**: (_bool_) distances weighted by process or point measurements within area (```True```) or not (```False```).\n",
    "\n",
    "\n",
    "OUTPUT:\n",
    "\n",
    "- (```numpy array```) distances from known locations to the unknown location:\n",
    "\n",
    "```python\n",
    "[\n",
    "    id_known,\n",
    "    coordinate x,\n",
    "    coordinate y,\n",
    "    value,\n",
    "    distance to unknown,\n",
    "    aggregated points values within an area\n",
    "]\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "***"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ```prepare_ata_data()```\n",
    "\n",
    "```python\n",
    "pyinterpolate.transform.prepare_ata_data(\n",
    "    points_within_unknown_area,\n",
    "    known_areas,\n",
    "    points_within_known_areas,\n",
    "    number_of_neighbours,\n",
    "    max_search_radius)\n",
    "```\n",
    "\n",
    "Function prepares data for Area to Area Poisson Kriging.\n",
    "\n",
    "\n",
    "INPUT:\n",
    "\n",
    "- **points_within_unknown_area**: (_numpy array_) points and their values within the unknown area:\n",
    "\n",
    "```python\n",
    "[\n",
    "    area_id,\n",
    "    [point_position_x, point_position_y, value of point]\n",
    "]\n",
    "```\n",
    "- **known_areas**: (_numpy array_) known areas in the form:\n",
    "\n",
    "```python\n",
    "[area_id, polygon, centroid x, centroid y, aggregated value]\n",
    "```\n",
    "- **points_within_known_areas**: (_numpy array_) points and their values within the given area:\n",
    "\n",
    "```python\n",
    "[\n",
    "    [area_id,\n",
    "    [point_position_x, point_position_y, value of point]]\n",
    "]\n",
    "```\n",
    "- **number_of_neighbours**: (_int_) minimum number of neighbours to include in the algorithm,\n",
    "- **max_search_radius**: (_float_) maximum search radius (if number of neighbours within this search radius is smaller than ```number_of_neighbours``` parameter then additional neighbours are included up to the minimum number of neighbors).\n",
    "\n",
    "\n",
    "OUTPUT:\n",
    "\n",
    "- (```numpy array```) distances from known locations to the unknown location:\n",
    "\n",
    "```python\n",
    "[\n",
    "    id_known,\n",
    "    areal value - count,\n",
    "    [known_point_1 value, unknown_point_1 value, distance_1],\n",
    "    total point value\n",
    "]\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "***"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ```prepare_atp_data()```\n",
    "\n",
    "```python\n",
    "pyinterpolate.transform.prepare_atp_data(\n",
    "    points_within_unknown_area,\n",
    "    known_areas,\n",
    "    points_within_known_areas,\n",
    "    number_of_neighbours,\n",
    "    max_search_radius)\n",
    "```\n",
    "\n",
    "Function prepares data for Area to Point Poisson Kriging.\n",
    "\n",
    "\n",
    "INPUT:\n",
    "\n",
    "- **points_within_unknown_area**: (_numpy array_) points and their values within the unknown area:\n",
    "\n",
    "```python\n",
    "[\n",
    "    area_id,\n",
    "    [point_position_x, point_position_y, value of point]\n",
    "]\n",
    "```\n",
    "- **known_areas**: (_numpy array_) known areas in the form:\n",
    "\n",
    "```python\n",
    "[area_id, polygon, centroid x, centroid y, aggregated value]\n",
    "```\n",
    "- **points_within_known_areas**: (_numpy array_) points and their values within the given area:\n",
    "\n",
    "```python\n",
    "[\n",
    "    [area_id,\n",
    "    [point_position_x, point_position_y, value of point]]\n",
    "]\n",
    "```\n",
    "- **number_of_neighbours**: (_int_) minimum number of neighbours to include in the algorithm,\n",
    "- **max_search_radius**: (_float_) maximum search radius (if number of neighbours within this search radius is smaller than ```number_of_neighbours``` parameter then additional neighbours are included up to the minimum number of neighbors).\n",
    "\n",
    "\n",
    "OUTPUT:\n",
    "\n",
    "- (```numpy array```) distances from known locations to the unknown location:\n",
    "\n",
    "```python\n",
    "[\n",
    "    id_known,\n",
    "    areal value - count,\n",
    "    [\n",
    "        unknown point value, \n",
    "        [known point values, distance],\n",
    "        total point value count\n",
    "    ],\n",
    "    [array of unknown area points coordinates]\n",
    "]\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "***"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ```select_values_in_range()```\n",
    "\n",
    "```python\n",
    "pyinterpolate.transform.select_values_in_range(\n",
    "    data,\n",
    "    lag,\n",
    "    step_size)\n",
    "```\n",
    "\n",
    "Function selects set of values which are greater than (```lag - step size / 2```) and smaller or equal than (```lag + step size / 2```).\n",
    "\n",
    "INPUT:\n",
    "\n",
    "- **data**: (_numpy array_) distances,\n",
    "- **lag**: (_float_) lag within areas are included,\n",
    "- **step_size**: (_float_) step between lags.\n",
    "\n",
    "\n",
    "OUTPUT:\n",
    "\n",
    "- ```numpy array``` mask with distances within specified radius."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "***"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ```set_areal_weights()```\n",
    "\n",
    "```python\n",
    "pyinterpolate.transform.set_areal_weights(\n",
    "    areal_data,\n",
    "    areal_points)\n",
    "```\n",
    "\n",
    "Function prepares array for _weighted semivariance_ calculation.\n",
    "\n",
    "INPUT:\n",
    "\n",
    "- **areal_data**: (_numpy array_) of areas in the form:\n",
    "\n",
    "```python\n",
    "[area_id, areal_polygon, centroid coordinate x, centroid coordinate y, value]\n",
    "```\n",
    "\n",
    "- **areal_points**: (_numpy array_) of points within areas in the form:\n",
    "\n",
    "```python\n",
    "[area_id, [point_position_x, point_position_y, value]]\n",
    "````\n",
    "\n",
    "\n",
    "OUTPUT:\n",
    "\n",
    "- ```numpy array``` of weighted points."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}