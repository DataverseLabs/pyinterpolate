<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>API &#8212; Pyinterpolate 0.3.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Poisson Kriging - Area to Point Kriging" href="../usage/tutorials/Poisson%20Kriging%20-%20Area%20to%20Point%20%28Advanced%29.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          Pyinterpolate</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../setup/setup.html">Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/tutorials.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">API</a><ul>
<li><a class="reference internal" href="#distance-calculations">Distance calculations</a></li>
<li><a class="reference internal" href="#inverse-distance-weighting">Inverse Distance Weighting</a></li>
<li><a class="reference internal" href="#input-output">Input / Output</a></li>
<li><a class="reference internal" href="#kriging">Kriging</a><ul>
<li><a class="reference internal" href="#point-kriging">Point Kriging</a></li>
<li><a class="reference internal" href="#block-poisson-kriging">Block - Poisson Kriging</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pipelines">Pipelines</a><ul>
<li><a class="reference internal" href="#kriging-based-processes">Kriging-based processes</a></li>
<li><a class="reference internal" href="#data-download">Data download</a></li>
</ul>
</li>
<li><a class="reference internal" href="#core-data-structures">Core data structures</a></li>
<li><a class="reference internal" href="#variogram">Variogram</a><ul>
<li><a class="reference internal" href="#experimental">Experimental</a></li>
<li><a class="reference internal" href="#theoretical">Theoretical</a></li>
<li><a class="reference internal" href="#block">Block</a></li>
<li><a class="reference internal" href="#deconvolution">Deconvolution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#visualization">Visualization</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="../usage/tutorials/Poisson%20Kriging%20-%20Area%20to%20Point%20%28Advanced%29.html" title="Previous Chapter: Poisson Kriging - Area to Point Kriging"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; Poisson Krigi...</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="../_sources/api/api.rst.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <section id="api">
<h1>API<a class="headerlink" href="#api" title="Permalink to this heading">¶</a></h1>
<section id="distance-calculations">
<h2>Distance calculations<a class="headerlink" href="#distance-calculations" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">calc_point_to_point_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points_b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/distance/distance.html#calc_point_to_point_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Function calculates distances between two group of points of a single group to itself.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points_a</strong><span class="classifier">numpy array</span></dt><dd><p>The point coordinates.</p>
</dd>
<dt><strong>points_b</strong><span class="classifier">numpy array, default=None</span></dt><dd><p>Other point coordinates. If provided then algorithm calculates distances between <code class="docutils literal notranslate"><span class="pre">points_a</span></code> against
<code class="docutils literal notranslate"><span class="pre">points_b</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>distances</strong><span class="classifier">numpy array</span></dt><dd><p>The distances from each point from the <code class="docutils literal notranslate"><span class="pre">points_a</span></code> to other point (from the same <code class="docutils literal notranslate"><span class="pre">points_a</span></code> or from the
other set of points <code class="docutils literal notranslate"><span class="pre">points_b</span></code>).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">calc_block_to_block_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">blocks</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/distance/distance.html#calc_block_to_block_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Function calculates distances between blocks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>blocks</strong><span class="classifier">Union[Dict, np.ndarray, gpd.GeoDataFrame, pd.DataFrame, PointSupport]</span></dt><dd><dl class="simple">
<dt>The point support of polygons.</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Dict</span></code>: <code class="docutils literal notranslate"><span class="pre">{block</span> <span class="pre">id:</span> <span class="pre">[[point</span> <span class="pre">x,</span> <span class="pre">point</span> <span class="pre">y,</span> <span class="pre">value]]}</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>: <code class="docutils literal notranslate"><span class="pre">[[block</span> <span class="pre">id,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">value]]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> and <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code>: <code class="docutils literal notranslate"><span class="pre">columns={x,</span> <span class="pre">y,</span> <span class="pre">ds,</span> <span class="pre">index}</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PointSupport</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>block_distances</strong><span class="classifier">Dict</span></dt><dd><p>Ordered block ids (the order from the list of distances): {block id : [distances to other]}.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>Wrong input’s data type.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<hr class="docutils" />
<section id="inverse-distance-weighting">
<h2>Inverse Distance Weighting<a class="headerlink" href="#inverse-distance-weighting" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">inverse_distance_weighting</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">known_points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unknown_location</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_neighbours</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/idw/idw.html#inverse_distance_weighting"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Inverse Distance Weighting with a given set of points and an unknown location.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>known_points</strong><span class="classifier">numpy array</span></dt><dd><p>The MxN array, where <strong>M</strong> is a number of rows (points) and <strong>N</strong> is the number of columns, where the last
column represents a value of a known point. (It could be <strong>(N-1)</strong>-dimensional data).</p>
</dd>
<dt><strong>unknown_location</strong><span class="classifier">Iterable</span></dt><dd><p>Array or list with coordinates of the unknown point. It’s length is N-1 (number of dimensions). The unknown
location <cite>shape</cite> should be the same as the <code class="docutils literal notranslate"><span class="pre">known_points</span></code> parameter <cite>shape</cite>, if not, then new dimension
is added once - vector of points <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y]</span></code> becomes <code class="docutils literal notranslate"><span class="pre">[[x,</span> <span class="pre">y]]</span></code> for 2-dimensional data.</p>
</dd>
<dt><strong>number_of_neighbours</strong><span class="classifier">int, default = -1</span></dt><dd><p>If default value <strong>(-1)</strong> then all known points will be used to estimate value at the unknown location.
Can be any number within the limits <code class="docutils literal notranslate"><span class="pre">[2,</span> <span class="pre">len(known_points)]</span></code>,</p>
</dd>
<dt><strong>power</strong><span class="classifier">float, default = 2.</span></dt><dd><p>Power value must be larger or equal to 0. It controls weight assigned to each known point. Larger power means
stronger influence of the closest neighbors, but it decreases quickly.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">float</span></dt><dd><p>The estimated value.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Power parameter set to be smaller than 0.</p>
</dd>
<dt>ValueError</dt><dd><p>Less than 2 neighbours or more than the number of <code class="docutils literal notranslate"><span class="pre">known_points</span></code> neighbours are given in the
<code class="docutils literal notranslate"><span class="pre">number_of_neighbours</span></code> parameter.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<hr class="docutils" />
<section id="input-output">
<h2>Input / Output<a class="headerlink" href="#input-output" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">read_block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_col_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry_col_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'geometry'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id_col_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid_col_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/io/read_data.html#read_block"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Function reads block data from files supported by fiona / geopandas.</p>
<p>Value column name must be provided. If geometry column has different name than <cite>‘geometry’</cite> then
it must be provided too. ID column name is optional, if not given then <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> <cite>index</cite> is
treated as an id column. Optional parameters are <cite>epsg</cite> and <cite>crs</cite>. If any is set then data is reprojected
into a specific <cite>crs/epsg</cite>.` Function returns <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> with columns: <code class="docutils literal notranslate"><span class="pre">[id,</span> <span class="pre">value,</span> <span class="pre">geometry,</span> <span class="pre">centroid]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>Path to the file.</p>
</dd>
<dt><strong>val_col_name</strong><span class="classifier">str</span></dt><dd><p>Name of the value column (header title).</p>
</dd>
<dt><strong>geometry_col_name</strong><span class="classifier">str, default=’geometry’</span></dt><dd><p>Name of the column with polygons.</p>
</dd>
<dt><strong>id_col_name: str or None, default=None, optional</strong></dt><dd><p>Name of the colum with unique indexes.</p>
</dd>
<dt><strong>centroid_col_name: str or None, default=None</strong></dt><dd><p>Name of the column with block centroid. Centroids are calculated from <code class="docutils literal notranslate"><span class="pre">MultiPolygon</span></code> or <code class="docutils literal notranslate"><span class="pre">Polygon</span></code>
later on but their accuracy may be limited. For most applications it does not matter.</p>
</dd>
<dt><strong>epsg</strong><span class="classifier">str or None, default=None</span></dt><dd><p>If provided then <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> projection is set to it. You should choose if you provide <cite>EPSG</cite> or <cite>CRS</cite>.</p>
</dd>
<dt><strong>crs</strong><span class="classifier">str or None, default=None</span></dt><dd><p>If provided then <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> projection is set to it. You should choose if you provide <cite>CRS</cite> or <cite>EPSG</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gpd</strong><span class="classifier">GeoDataFrame</span></dt><dd><p>Returned output has columns: <code class="docutils literal notranslate"><span class="pre">['id',</span> <span class="pre">'geometry',</span> <span class="pre">'value',</span> <span class="pre">'centroid']</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p><cite>EPSG</cite> and <cite>CRS</cite> are provided both (should be only one).</p>
</dd>
<dt>TypeError</dt><dd><p>Provided column name does not exist in a dataset.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bblock</span> <span class="o">=</span> <span class="s1">&#39;path_to_the_shapefile.shp&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bdf</span> <span class="o">=</span> <span class="n">read_block</span><span class="p">(</span><span class="n">bblock</span><span class="p">,</span> <span class="n">val_col_name</span><span class="o">=</span><span class="s1">&#39;rate&#39;</span><span class="p">,</span> <span class="n">id_col_name</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bdf</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
<span class="go">Index([&#39;id&#39;, &#39;geometry&#39;, &#39;rate&#39;, &#39;centroid&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">read_csv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_col_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_col_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon_col_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">','</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/io/read_data.html#read_csv"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Function reads data from a csv file.</p>
<p>Provided data should include: <strong>latitude</strong>, <strong>longitude</strong>, <strong>value</strong>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>Path to the file.</p>
</dd>
<dt><strong>val_col_name</strong><span class="classifier">str</span></dt><dd><p>Name of the value column (header title).</p>
</dd>
<dt><strong>lat_col_name</strong><span class="classifier">str</span></dt><dd><p>Name of the latitude column (header title).</p>
</dd>
<dt><strong>lon_col_name</strong><span class="classifier">str</span></dt><dd><p>Name of the longitude column (header title).</p>
</dd>
<dt><strong>delim</strong><span class="classifier">str, default=’,’</span></dt><dd><p>Delimiter that separates columns.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data_arr</strong><span class="classifier">numpy array</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">path_to_the_data</span> <span class="o">=</span> <span class="s1">&#39;path_to_the_data.csv&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">path_to_the_data</span><span class="p">,</span> <span class="n">val_col_name</span><span class="o">=</span><span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="n">lat_col_name</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">lon_col_name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
<span class="go">[</span>
<span class="go">    [15.11524 52.76515 91.275597]</span>
<span class="go">    [15.11524 52.74279 96.548294]</span>
<span class="go">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">read_txt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">','</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/io/read_data.html#read_txt"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Function reads data from a text file.</p>
<p>Provided data format should include: <strong>longitude (x)</strong>, <strong>latitude (y)</strong>, <strong>value</strong>. Function converts data into
numpy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>Path to the file.</p>
</dd>
<dt><strong>delim</strong><span class="classifier">str, default=’,’</span></dt><dd><p>Delimiter that separates columns.</p>
</dd>
<dt><strong>skip_header</strong><span class="classifier">bool, default=True</span></dt><dd><p>Skips the first row of a file if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data_arr</strong><span class="classifier">numpy array</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">path_to_the_data</span> <span class="o">=</span> <span class="s1">&#39;path_to_the_data.txt&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">read_txt</span><span class="p">(</span><span class="n">path_to_the_data</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
<span class="go">[</span>
<span class="go">    [15.11524 52.76515 91.275597]</span>
<span class="go">    [15.11524 52.74279 96.548294]</span>
<span class="go">]</span>
</pre></div>
</div>
</dd></dl>

</section>
<hr class="docutils" />
<section id="kriging">
<h2>Kriging<a class="headerlink" href="#kriging" title="Permalink to this heading">¶</a></h2>
<section id="point-kriging">
<h3>Point Kriging<a class="headerlink" href="#point-kriging" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">kriging</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theoretical_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">how</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ok'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbors_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_all_neighbors_in_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sk_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_approx_solutions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_to_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_workers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/kriging/point_kriging.html#kriging"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Function manages Ordinary Kriging and Simple Kriging predictions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>observations</strong><span class="classifier">numpy array</span></dt><dd><p>Known points and their values.</p>
</dd>
<dt><strong>theoretical_model</strong><span class="classifier">TheoreticalVariogram</span></dt><dd><p>Fitted variogram model.</p>
</dd>
<dt><strong>points</strong><span class="classifier">numpy array</span></dt><dd><p>Coordinates with missing values (to estimate results).</p>
</dd>
<dt><strong>how</strong><span class="classifier">str, default=’ok’</span></dt><dd><dl class="simple">
<dt>Select what kind of kriging you want to perform:</dt><dd><ul class="simple">
<li><p>‘ok’: ordinary kriging,</p></li>
<li><p>‘sk’: simple kriging - if it is set then <code class="docutils literal notranslate"><span class="pre">sk_mean</span></code> parameter must be provided.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>neighbors_range</strong><span class="classifier">float, default=None</span></dt><dd><p>The maximum distance where we search for neighbors. If <code class="docutils literal notranslate"><span class="pre">None</span></code> is given then range is selected from
the <code class="docutils literal notranslate"><span class="pre">theoretical_model</span></code> <code class="docutils literal notranslate"><span class="pre">rang</span></code> attribute.</p>
</dd>
<dt><strong>no_neighbors</strong><span class="classifier">int, default = 4</span></dt><dd><p>The number of the <strong>n-closest neighbors</strong> used for interpolation.</p>
</dd>
<dt><strong>use_all_neighbors_in_range</strong><span class="classifier">bool, default = False</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: if the real number of neighbors within the <code class="docutils literal notranslate"><span class="pre">neighbors_range</span></code> is greater than the
<code class="docutils literal notranslate"><span class="pre">number_of_neighbors</span></code> parameter then take all of them anyway.</p>
</dd>
<dt><strong>sk_mean</strong><span class="classifier">float, default=None</span></dt><dd><p>The mean value of a process over a study area. Should be know before processing. That’s why Simple
Kriging has a limited number of applications. You must have multiple samples and well-known area to
know this parameter.</p>
</dd>
<dt><strong>allow_approx_solutions</strong><span class="classifier">bool, default=False</span></dt><dd><p>Allows the approximation of kriging weights based on the OLS algorithm. We don’t recommend set it to <code class="docutils literal notranslate"><span class="pre">True</span></code>
if you don’t know what are you doing.</p>
</dd>
<dt><strong>err_to_nan</strong><span class="classifier">bool, default=False</span></dt><dd><p>Return <code class="docutils literal notranslate"><span class="pre">NaN</span></code> if algorithm detects singular matrix.</p>
</dd>
<dt><strong>number_of_workers</strong><span class="classifier">int, default=1</span></dt><dd><p>How many processing units can be used for predictions. Increase it only for a very large number of
interpolated points (~10k+).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>: numpy array</dt><dd><p>Predictions <code class="docutils literal notranslate"><span class="pre">[predicted</span> <span class="pre">value,</span> <span class="pre">variance</span> <span class="pre">error,</span> <span class="pre">longitude</span> <span class="pre">(x),</span> <span class="pre">latitude</span> <span class="pre">(y)]</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ordinary_kriging</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theoretical_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">known_locations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unknown_location</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbors_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_all_neighbors_in_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_approximate_solutions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_to_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/kriging/models/point/ordinary_kriging.html#ordinary_kriging"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Function predicts value at unknown location with Ordinary Kriging technique.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theoretical_model</strong><span class="classifier">TheoreticalVariogram</span></dt><dd><p>A trained theoretical variogram model.</p>
</dd>
<dt><strong>known_locations</strong><span class="classifier">numpy array</span></dt><dd><p>The known locations.</p>
</dd>
<dt><strong>unknown_location</strong><span class="classifier">Union[List, Tuple, numpy array]</span></dt><dd><p>Point where you want to estimate value <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span> <span class="pre">&lt;-&gt;</span> <span class="pre">(lon,</span> <span class="pre">lat)</span></code>.</p>
</dd>
<dt><strong>neighbors_range</strong><span class="classifier">float, default=None</span></dt><dd><p>The maximum distance where we search for neighbors. If <code class="docutils literal notranslate"><span class="pre">None</span></code> is given then range is selected from
the <code class="docutils literal notranslate"><span class="pre">theoretical_model</span></code> <code class="docutils literal notranslate"><span class="pre">rang</span></code> attribute.</p>
</dd>
<dt><strong>no_neighbors</strong><span class="classifier">int, default = 4</span></dt><dd><p>The number of the <strong>n-closest neighbors</strong> used for interpolation.</p>
</dd>
<dt><strong>use_all_neighbors_in_range</strong><span class="classifier">bool, default = False</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: if the real number of neighbors within the <code class="docutils literal notranslate"><span class="pre">neighbors_range</span></code> is greater than the
<code class="docutils literal notranslate"><span class="pre">number_of_neighbors</span></code> parameter then take all of them anyway.</p>
</dd>
<dt><strong>allow_approx_solutions</strong><span class="classifier">bool, default=False</span></dt><dd><p>Allows the approximation of kriging weights based on the OLS algorithm. We don’t recommend set it to <code class="docutils literal notranslate"><span class="pre">True</span></code>
if you don’t know what are you doing.</p>
</dd>
<dt><strong>err_to_nan</strong><span class="classifier">bool, default=False</span></dt><dd><p>Return <code class="docutils literal notranslate"><span class="pre">NaN</span></code> if algorithm detects singular matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>: numpy array</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[predicted</span> <span class="pre">value,</span> <span class="pre">variance</span> <span class="pre">error,</span> <span class="pre">longitude</span> <span class="pre">(x),</span> <span class="pre">latitude</span> <span class="pre">(y)]</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">simple_kriging</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theoretical_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">known_locations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unknown_location</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">process_mean</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbors_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_all_neighbors_in_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_approximate_solutions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_to_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/kriging/models/point/simple_kriging.html#simple_kriging"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Function predicts value at unknown location with Ordinary Kriging technique.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theoretical_model</strong><span class="classifier">TheoreticalVariogram</span></dt><dd><p>A trained theoretical variogram model.</p>
</dd>
<dt><strong>known_locations</strong><span class="classifier">numpy array</span></dt><dd><p>The known locations.</p>
</dd>
<dt><strong>unknown_location</strong><span class="classifier">Union[List, Tuple, numpy array]</span></dt><dd><p>Point where you want to estimate value <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span> <span class="pre">&lt;-&gt;</span> <span class="pre">(lon,</span> <span class="pre">lat)</span></code>.</p>
</dd>
<dt><strong>process_mean</strong><span class="classifier">float</span></dt><dd><p>The mean value of a process over a study area. Should be know before processing. That’s why Simple
Kriging has a limited number of applications. You must have multiple samples and well-known area to
know this parameter.</p>
</dd>
<dt><strong>neighbors_range</strong><span class="classifier">float, default=None</span></dt><dd><p>The maximum distance where we search for neighbors. If <code class="docutils literal notranslate"><span class="pre">None</span></code> is given then range is selected from
the <code class="docutils literal notranslate"><span class="pre">theoretical_model</span></code> <code class="docutils literal notranslate"><span class="pre">rang</span></code> attribute.</p>
</dd>
<dt><strong>no_neighbors</strong><span class="classifier">int, default = 4</span></dt><dd><p>The number of the <strong>n-closest neighbors</strong> used for interpolation.</p>
</dd>
<dt><strong>use_all_neighbors_in_range</strong><span class="classifier">bool, default = False</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: if the real number of neighbors within the <code class="docutils literal notranslate"><span class="pre">neighbors_range</span></code> is greater than the
<code class="docutils literal notranslate"><span class="pre">number_of_neighbors</span></code> parameter then take all of them anyway.</p>
</dd>
<dt><strong>allow_approx_solutions</strong><span class="classifier">bool, default=False</span></dt><dd><p>Allows the approximation of kriging weights based on the OLS algorithm. We don’t recommend set it to <code class="docutils literal notranslate"><span class="pre">True</span></code>
if you don’t know what are you doing.</p>
</dd>
<dt><strong>err_to_nan</strong><span class="classifier">bool, default=False</span></dt><dd><p>Return <code class="docutils literal notranslate"><span class="pre">NaN</span></code> if algorithm detects singular matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>: numpy array</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[predicted</span> <span class="pre">value,</span> <span class="pre">variance</span> <span class="pre">error,</span> <span class="pre">longitude</span> <span class="pre">(x),</span> <span class="pre">latitude</span> <span class="pre">(y)]</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="block-poisson-kriging">
<h3>Block - Poisson Kriging<a class="headerlink" href="#block-poisson-kriging" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">centroid_poisson_kriging</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">semivariogram_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_support</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unknown_block</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unknown_block_point_support</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_neighbors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_weighted_by_point_support</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_when_negative_prediction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_when_negative_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/kriging/models/block/centroid_based_poisson_kriging.html#centroid_poisson_kriging"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Function performs centroid-based Poisson Kriging of blocks (areal) data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>semivariogram_model</strong><span class="classifier">TheoreticalVariogram</span></dt><dd><p>A fitted variogram.</p>
</dd>
<dt><strong>blocks</strong><span class="classifier">Union[Blocks, gpd.GeoDataFrame, pd.DataFrame, np.ndarray]</span></dt><dd><dl class="simple">
<dt>Blocks with aggregated data.</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Blocks</span></code>: <code class="docutils literal notranslate"><span class="pre">Blocks()</span></code> class object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> must have columns: <code class="docutils literal notranslate"><span class="pre">centroid.x,</span> <span class="pre">centroid.y,</span> <span class="pre">ds,</span> <span class="pre">index</span></code>.
Geometry column with polygons is not used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>: <code class="docutils literal notranslate"><span class="pre">[[block</span> <span class="pre">index,</span> <span class="pre">centroid</span> <span class="pre">x,</span> <span class="pre">centroid</span> <span class="pre">y,</span> <span class="pre">value]]</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>point_support</strong><span class="classifier">Union[Dict, np.ndarray, gpd.GeoDataFrame, pd.DataFrame, PointSupport]</span></dt><dd><dl class="simple">
<dt>The point support of polygons.</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Dict</span></code>: <code class="docutils literal notranslate"><span class="pre">{block</span> <span class="pre">id:</span> <span class="pre">[[point</span> <span class="pre">x,</span> <span class="pre">point</span> <span class="pre">y,</span> <span class="pre">value]]}</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>: <code class="docutils literal notranslate"><span class="pre">[[block</span> <span class="pre">id,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">value]]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> and <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code>: <code class="docutils literal notranslate"><span class="pre">columns={x,</span> <span class="pre">y,</span> <span class="pre">ds,</span> <span class="pre">index}</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PointSupport</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>unknown_block</strong><span class="classifier">numpy array</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">[index,</span> <span class="pre">centroid.x,</span> <span class="pre">centroid.y]</span></code></p>
</dd>
<dt><strong>unknown_block_point_support</strong><span class="classifier">numpy array</span></dt><dd><p>Points within block <code class="docutils literal notranslate"><span class="pre">[[x,</span> <span class="pre">y,</span> <span class="pre">point</span> <span class="pre">support</span> <span class="pre">value]]</span></code></p>
</dd>
<dt><strong>number_of_neighbors</strong><span class="classifier">int</span></dt><dd><p>The minimum number of neighbours that can potentially affect block.</p>
</dd>
<dt><strong>is_weighted_by_point_support</strong><span class="classifier">bool, default = True</span></dt><dd><p>Are distances between blocks weighted by the point support?</p>
</dd>
<dt><strong>raise_when_negative_prediction</strong><span class="classifier">bool, default=True</span></dt><dd><p>Raise error when prediction is negative.</p>
</dd>
<dt><strong>raise_when_negative_error</strong><span class="classifier">bool, default=True</span></dt><dd><p>Raise error when prediction error is negative.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>results</strong><span class="classifier">List</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">[unknown</span> <span class="pre">block</span> <span class="pre">index,</span> <span class="pre">prediction,</span> <span class="pre">error]</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Prediction or prediction error are negative.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">area_to_area_pk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">semivariogram_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_support</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unknown_block</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unknown_block_point_support</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_neighbors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_when_negative_prediction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_when_negative_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/kriging/models/block/area_to_area_poisson_kriging.html#area_to_area_pk"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Function predicts areal value in a unknown location based on the area-to-area Poisson Kriging</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>semivariogram_model</strong><span class="classifier">TheoreticalVariogram</span></dt><dd><p>A fitted variogram.</p>
</dd>
<dt><strong>blocks</strong><span class="classifier">Union[Blocks, gpd.GeoDataFrame, pd.DataFrame, np.ndarray]</span></dt><dd><dl class="simple">
<dt>Blocks with aggregated data.</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Blocks</span></code>: <code class="docutils literal notranslate"><span class="pre">Blocks()</span></code> class object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> must have columns: <code class="docutils literal notranslate"><span class="pre">centroid.x,</span> <span class="pre">centroid.y,</span> <span class="pre">ds,</span> <span class="pre">index</span></code>.
Geometry column with polygons is not used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>: <code class="docutils literal notranslate"><span class="pre">[[block</span> <span class="pre">index,</span> <span class="pre">centroid</span> <span class="pre">x,</span> <span class="pre">centroid</span> <span class="pre">y,</span> <span class="pre">value]]</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>point_support</strong><span class="classifier">Union[Dict, np.ndarray, gpd.GeoDataFrame, pd.DataFrame, PointSupport]</span></dt><dd><dl class="simple">
<dt>The point support of polygons.</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Dict</span></code>: <code class="docutils literal notranslate"><span class="pre">{block</span> <span class="pre">id:</span> <span class="pre">[[point</span> <span class="pre">x,</span> <span class="pre">point</span> <span class="pre">y,</span> <span class="pre">value]]}</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>: <code class="docutils literal notranslate"><span class="pre">[[block</span> <span class="pre">id,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">value]]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> and <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code>: <code class="docutils literal notranslate"><span class="pre">columns={x,</span> <span class="pre">y,</span> <span class="pre">ds,</span> <span class="pre">index}</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PointSupport</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>unknown_block</strong><span class="classifier">numpy array</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">[index,</span> <span class="pre">centroid.x,</span> <span class="pre">centroid.y]</span></code></p>
</dd>
<dt><strong>unknown_block_point_support</strong><span class="classifier">numpy array</span></dt><dd><p>Points within block <code class="docutils literal notranslate"><span class="pre">[[x,</span> <span class="pre">y,</span> <span class="pre">point</span> <span class="pre">support</span> <span class="pre">value]]</span></code></p>
</dd>
<dt><strong>number_of_neighbors</strong><span class="classifier">int</span></dt><dd><p>The minimum number of neighbours that can potentially affect block.</p>
</dd>
<dt><strong>raise_when_negative_prediction</strong><span class="classifier">bool, default=True</span></dt><dd><p>Raise error when prediction is negative.</p>
</dd>
<dt><strong>raise_when_negative_error</strong><span class="classifier">bool, default=True</span></dt><dd><p>Raise error when prediction error is negative.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>results</strong><span class="classifier">List</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">[unknown</span> <span class="pre">block</span> <span class="pre">index,</span> <span class="pre">prediction,</span> <span class="pre">error]</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Prediction or prediction error are negative.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">area_to_point_pk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">semivariogram_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_support</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unknown_block</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unknown_block_point_support</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_neighbors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_when_negative_prediction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_when_negative_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_to_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/kriging/models/block/area_to_point_poisson_kriging.html#area_to_point_pk"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Function predicts areal value in the unknown location based on the area-to-area Poisson Kriging</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>semivariogram_model</strong><span class="classifier">TheoreticalVariogram</span></dt><dd><p>A fitted variogram.</p>
</dd>
<dt><strong>blocks</strong><span class="classifier">Union[Blocks, gpd.GeoDataFrame, pd.DataFrame, np.ndarray]</span></dt><dd><dl class="simple">
<dt>Blocks with aggregated data.</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Blocks</span></code>: <code class="docutils literal notranslate"><span class="pre">Blocks()</span></code> class object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> must have columns: <code class="docutils literal notranslate"><span class="pre">centroid.x,</span> <span class="pre">centroid.y,</span> <span class="pre">ds,</span> <span class="pre">index</span></code>.
Geometry column with polygons is not used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>: <code class="docutils literal notranslate"><span class="pre">[[block</span> <span class="pre">index,</span> <span class="pre">centroid</span> <span class="pre">x,</span> <span class="pre">centroid</span> <span class="pre">y,</span> <span class="pre">value]]</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>point_support</strong><span class="classifier">Union[Dict, np.ndarray, gpd.GeoDataFrame, pd.DataFrame, PointSupport]</span></dt><dd><dl class="simple">
<dt>The point support of polygons.</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Dict</span></code>: <code class="docutils literal notranslate"><span class="pre">{block</span> <span class="pre">id:</span> <span class="pre">[[point</span> <span class="pre">x,</span> <span class="pre">point</span> <span class="pre">y,</span> <span class="pre">value]]}</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>: <code class="docutils literal notranslate"><span class="pre">[[block</span> <span class="pre">id,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">value]]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> and <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code>: <code class="docutils literal notranslate"><span class="pre">columns={x,</span> <span class="pre">y,</span> <span class="pre">ds,</span> <span class="pre">index}</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PointSupport</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>unknown_block</strong><span class="classifier">numpy array</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">[index,</span> <span class="pre">centroid.x,</span> <span class="pre">centroid.y]</span></code></p>
</dd>
<dt><strong>unknown_block_point_support</strong><span class="classifier">numpy array</span></dt><dd><p>Points within block <code class="docutils literal notranslate"><span class="pre">[[x,</span> <span class="pre">y,</span> <span class="pre">point</span> <span class="pre">support</span> <span class="pre">value]]</span></code></p>
</dd>
<dt><strong>number_of_neighbors</strong><span class="classifier">int</span></dt><dd><p>The minimum number of neighbours that can potentially affect block.</p>
</dd>
<dt><strong>max_range</strong><span class="classifier">float , default=None</span></dt><dd><p>The maximum distance to search for a neighbors, if <code class="docutils literal notranslate"><span class="pre">None</span></code> given then algorithm uses
the theoretical variogram’s range.</p>
</dd>
<dt><strong>raise_when_negative_prediction</strong><span class="classifier">bool, default=True</span></dt><dd><p>Raise error when prediction is negative.</p>
</dd>
<dt><strong>raise_when_negative_error</strong><span class="classifier">bool, default=True</span></dt><dd><p>Raise error when prediction error is negative.</p>
</dd>
<dt><strong>err_to_nan</strong><span class="classifier">bool, default=True</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">ValueError</span></code> to <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>results</strong><span class="classifier">List</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">[(unknown</span> <span class="pre">point</span> <span class="pre">coordinates),</span> <span class="pre">prediction,</span> <span class="pre">error]</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Prediction or prediction error are negative.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<hr class="docutils" />
<section id="pipelines">
<h2>Pipelines<a class="headerlink" href="#pipelines" title="Permalink to this heading">¶</a></h2>
<section id="kriging-based-processes">
<h3>Kriging-based processes<a class="headerlink" href="#kriging-based-processes" title="Permalink to this heading">¶</a></h3>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BlockFilter</span></span></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">BlockPK</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BlockPK</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">semivariogram_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_support</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kriging_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ata'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/pipelines/block_filtering.html#BlockPK"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Class is an object that can be used for Area-to-Area, Area-to-Point, Centroid-based Poisson Kriging
regularization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>semivariogram_model</strong><span class="classifier">TheoreticalVariogram</span></dt><dd><p>The fitted variogram model.</p>
</dd>
<dt><strong>blocks</strong><span class="classifier">Union[Blocks, gpd.GeoDataFrame, pd.DataFrame, np.ndarray]</span></dt><dd><dl class="simple">
<dt>Blocks with aggregated data.</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Blocks</span></code>: <code class="docutils literal notranslate"><span class="pre">Blocks()</span></code> class object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> must have columns: <code class="docutils literal notranslate"><span class="pre">centroid.x,</span> <span class="pre">centroid.y,</span> <span class="pre">ds,</span> <span class="pre">index</span></code>.
Geometry column with polygons is not used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>: <code class="docutils literal notranslate"><span class="pre">[[block</span> <span class="pre">index,</span> <span class="pre">centroid</span> <span class="pre">x,</span> <span class="pre">centroid</span> <span class="pre">y,</span> <span class="pre">value]]</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>point_support</strong><span class="classifier">Union[Dict, np.ndarray, gpd.GeoDataFrame, pd.DataFrame, PointSupport]</span></dt><dd><dl class="simple">
<dt>The point support of polygons.</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Dict</span></code>: <code class="docutils literal notranslate"><span class="pre">{block</span> <span class="pre">id:</span> <span class="pre">[[point</span> <span class="pre">x,</span> <span class="pre">point</span> <span class="pre">y,</span> <span class="pre">value]]}</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>: <code class="docutils literal notranslate"><span class="pre">[[block</span> <span class="pre">id,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">value]]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> and <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code>: <code class="docutils literal notranslate"><span class="pre">columns={x,</span> <span class="pre">y,</span> <span class="pre">ds,</span> <span class="pre">index}</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PointSupport</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>kriging_type</strong><span class="classifier">str, default=’ata’</span></dt><dd><dl class="simple">
<dt>A type of Poisson Kriging operation. Available methods:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'ata'</span></code>: Area-to-Area Poisson Kriging.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'atp'</span></code>: Area-to-Point Poisson Kriging.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'cb'</span></code>: Centroid-based Poisson Kriging.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>semivariogram_model</strong><span class="classifier">TheoreticalVariogram</span></dt><dd><p>See the <code class="docutils literal notranslate"><span class="pre">semivariogram_model</span></code> parameter.</p>
</dd>
<dt><strong>blocks</strong><span class="classifier">Union[Blocks, gpd.GeoDataFrame, pd.DataFrame, np.ndarray]</span></dt><dd><p>See the <code class="docutils literal notranslate"><span class="pre">blocks</span></code> parameter.</p>
</dd>
<dt><strong>point_support</strong><span class="classifier">Union[Dict, np.ndarray, gpd.GeoDataFrame, pd.DataFrame, PointSupport]</span></dt><dd><p>See the <code class="docutils literal notranslate"><span class="pre">point_support</span></code> parameter.</p>
</dd>
<dt><strong>kriging_type</strong><span class="classifier">str, default=’ata’</span></dt><dd><p>See the <code class="docutils literal notranslate"><span class="pre">kriging_type</span></code> parameter.</p>
</dd>
<dt><strong>geo_ds</strong><span class="classifier">geopandas GeoDataFrame</span></dt><dd><p>A regularized set of blocks: <code class="docutils literal notranslate"><span class="pre">['id',</span> <span class="pre">'geometry',</span> <span class="pre">'reg.est',</span> <span class="pre">'reg.err',</span> <span class="pre">'rmse']</span></code></p>
</dd>
<dt><strong>statistics</strong><span class="classifier">Dict</span></dt><dd><dl class="simple">
<dt>A dictionary with two keys:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'RMSE'</span></code>: root mean squared error of regularization,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'time'</span></code>: time (in seconds) of the regularization process.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>raise_when_negative_prediction</strong><span class="classifier">bool, default=True</span></dt><dd><p>Raise error when prediction is negative.</p>
</dd>
<dt><strong>raise_when_negative_error</strong><span class="classifier">bool, default=True</span></dt><dd><p>Raise error when prediction error is negative.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>regularize()</strong></p></td>
<td><p>Regularize blocks (you should use it for a data deconvolution - with ATP PK, or for a data filtering - with ATA, C-B PK).</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BlockToBlockKrigingComparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variogram</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_support</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_of_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbors_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simple_kriging_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_when_negative_prediction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_when_negative_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training_set_frac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_approx_solutions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/pipelines/multi_kriging.html#BlockToBlockKrigingComparison"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Class compares different block kriging models and techniques.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>blocks</strong><span class="classifier">Union[Blocks, gpd.GeoDataFrame, pd.DataFrame, np.ndarray]</span></dt><dd><dl class="simple">
<dt>Blocks with aggregated data.</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Blocks</span></code>: <code class="docutils literal notranslate"><span class="pre">Blocks()</span></code> class object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> must have columns: <code class="docutils literal notranslate"><span class="pre">centroid.x,</span> <span class="pre">centroid.y,</span> <span class="pre">ds,</span> <span class="pre">index</span></code>.
Geometry column with polygons is not used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>: <code class="docutils literal notranslate"><span class="pre">[[block</span> <span class="pre">index,</span> <span class="pre">centroid</span> <span class="pre">x,</span> <span class="pre">centroid</span> <span class="pre">y,</span> <span class="pre">value]]</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>point_support</strong><span class="classifier">Union[Dict, np.ndarray, gpd.GeoDataFrame, pd.DataFrame, PointSupport]</span></dt><dd><dl class="simple">
<dt>The point support of polygons.</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Dict</span></code>: <code class="docutils literal notranslate"><span class="pre">{block</span> <span class="pre">id:</span> <span class="pre">[[point</span> <span class="pre">x,</span> <span class="pre">point</span> <span class="pre">y,</span> <span class="pre">value]]}</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>: <code class="docutils literal notranslate"><span class="pre">[[block</span> <span class="pre">id,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">value]]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> and <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code>: <code class="docutils literal notranslate"><span class="pre">columns={x,</span> <span class="pre">y,</span> <span class="pre">ds,</span> <span class="pre">index}</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PointSupport</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>no_of_neighbors</strong><span class="classifier">int, default = 16</span></dt><dd><p>The maximum number of n-closest neighbors used for interpolation.</p>
</dd>
<dt><strong>neighbors_range</strong><span class="classifier">float, default = None</span></dt><dd><p>Maximum distance where we search for point neighbors. If None given then range is selected from
the <code class="docutils literal notranslate"><span class="pre">theoretical_model</span></code> <code class="docutils literal notranslate"><span class="pre">rang</span></code> attribute. If algorithms picks less neighbors than <code class="docutils literal notranslate"><span class="pre">no_of_neighbors</span></code>
within the range then additional points are selected outside the <code class="docutils literal notranslate"><span class="pre">neighbors_range</span></code>.</p>
</dd>
<dt><strong>simple_kriging_mean</strong><span class="classifier">float, default = None</span></dt><dd><p>The mean value of a process over a study area. Should be known before processing. If not provided then
Simple Kriging estimator is skipped.</p>
</dd>
<dt><strong>raise_when_negative_prediction</strong><span class="classifier">bool, default = True</span></dt><dd><p>Raise error when prediction is negative.</p>
</dd>
<dt><strong>raise_when_negative_error</strong><span class="classifier">bool, default=True</span></dt><dd><p>Raise error when prediction error is negative.</p>
</dd>
<dt><strong>training_set_frac</strong><span class="classifier">float, default = 0.8</span></dt><dd><p>How many values sampled as a known points set in each iteration. Could be any fraction within <code class="docutils literal notranslate"><span class="pre">(0:1)</span></code> range.</p>
</dd>
<dt><strong>allow_approx_solutions</strong><span class="classifier">bool, default = False</span></dt><dd><p>Allows the approximation of kriging weights based on the OLS algorithm. Not recommended to set to <code class="docutils literal notranslate"><span class="pre">True</span></code> if
you don’t know what you are doing!</p>
</dd>
<dt><strong>iters</strong><span class="classifier">int, default = 20</span></dt><dd><p>How many tests to perform over random samples of a data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>variogram</strong><span class="classifier">TheoreticalVariogram</span></dt><dd><p>See <code class="docutils literal notranslate"><span class="pre">variogram</span></code> parameter.</p>
</dd>
<dt><strong>blocks</strong><span class="classifier">Union[Blocks, gpd.GeoDataFrame, pd.DataFrame, np.ndarray]</span></dt><dd><p>See <code class="docutils literal notranslate"><span class="pre">blocks</span></code> parameter.</p>
</dd>
<dt><strong>point_support</strong><span class="classifier">Union[Dict, np.ndarray, gpd.GeoDataFrame, pd.DataFrame, PointSupport]</span></dt><dd><p>See <code class="docutils literal notranslate"><span class="pre">point_support</span></code> parameter.</p>
</dd>
<dt><strong>no_of_neighbors</strong><span class="classifier">int</span></dt><dd><p>See <code class="docutils literal notranslate"><span class="pre">no_of_neighbors</span></code> parameter.</p>
</dd>
<dt><strong>neighbors_range</strong><span class="classifier">float</span></dt><dd><p>See <code class="docutils literal notranslate"><span class="pre">neighbors_range</span></code> parameter.</p>
</dd>
<dt><strong>simple_kriging_mean</strong><span class="classifier">float</span></dt><dd><p>See <code class="docutils literal notranslate"><span class="pre">simple_kriging_mean</span></code> parameter.</p>
</dd>
<dt><strong>raise_when_negative_prediction</strong><span class="classifier">bool, default = True</span></dt><dd><p>See <code class="docutils literal notranslate"><span class="pre">raise_when_negative_prediction</span></code> parameter.</p>
</dd>
<dt><strong>raise_when_negative_error</strong><span class="classifier">bool, default=True</span></dt><dd><p>See <code class="docutils literal notranslate"><span class="pre">raise_when_negative_error</span></code> parameter.</p>
</dd>
<dt><strong>training_set_frac</strong><span class="classifier">float</span></dt><dd><p>See <code class="docutils literal notranslate"><span class="pre">training_set_frac</span></code> parameter.</p>
</dd>
<dt><strong>iters</strong><span class="classifier">int</span></dt><dd><p>See <code class="docutils literal notranslate"><span class="pre">iters</span></code> parameter.</p>
</dd>
<dt><strong>common_indexes</strong><span class="classifier">Set</span></dt><dd><p>Indexes that are common for blocks and point support.</p>
</dd>
<dt><strong>training_set_indexes</strong><span class="classifier">List[List]</span></dt><dd><p>List of lists with indexes used in a random sampling for a training set.</p>
</dd>
<dt><strong>results</strong><span class="classifier">Dict</span></dt><dd><p>Results for each type of Block Kriging method.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>run_tests()</strong></p></td>
<td><p>Compares different types of Kriging, returns Dict with the mean root mean squared error of each iteration.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">smooth_blocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">semivariogram_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_support</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_neighbors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_when_negative_prediction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_when_negative_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_to_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Function smooths blocks data into their point support values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>semivariogram_model</strong><span class="classifier">TheoreticalVariogram</span></dt><dd><p>The regularized variogram.</p>
</dd>
<dt><strong>blocks</strong><span class="classifier">Union[Blocks, gpd.GeoDataFrame, pd.DataFrame, np.ndarray]</span></dt><dd><dl class="simple">
<dt>Blocks with aggregated data.</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Blocks</span></code>: <code class="docutils literal notranslate"><span class="pre">Blocks()</span></code> class object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> must have columns: <code class="docutils literal notranslate"><span class="pre">centroid.x,</span> <span class="pre">centroid.y,</span> <span class="pre">ds,</span> <span class="pre">index</span></code>.
Geometry column with polygons is not used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>: <code class="docutils literal notranslate"><span class="pre">[[block</span> <span class="pre">index,</span> <span class="pre">centroid</span> <span class="pre">x,</span> <span class="pre">centroid</span> <span class="pre">y,</span> <span class="pre">value]]</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>point_support</strong><span class="classifier">Union[Dict, np.ndarray, gpd.GeoDataFrame, pd.DataFrame, PointSupport]</span></dt><dd><dl class="simple">
<dt>The point support of polygons.</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Dict</span></code>: <code class="docutils literal notranslate"><span class="pre">{block</span> <span class="pre">id:</span> <span class="pre">[[point</span> <span class="pre">x,</span> <span class="pre">point</span> <span class="pre">y,</span> <span class="pre">value]]}</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>: <code class="docutils literal notranslate"><span class="pre">[[block</span> <span class="pre">id,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">value]]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> and <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code>: <code class="docutils literal notranslate"><span class="pre">columns={x,</span> <span class="pre">y,</span> <span class="pre">ds,</span> <span class="pre">index}</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PointSupport</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>number_of_neighbors</strong><span class="classifier">int</span></dt><dd><p>The minimum number of neighbours that potentially affect block.</p>
</dd>
<dt><strong>max_range</strong><span class="classifier">float, default=None</span></dt><dd><p>The maximum distance to search for neighbors.</p>
</dd>
<dt><strong>crs</strong><span class="classifier">Any, default=None</span></dt><dd><p>CRS of data.</p>
</dd>
<dt><strong>raise_when_negative_prediction</strong><span class="classifier">bool, default=True</span></dt><dd><p>Raise error when prediction is negative.</p>
</dd>
<dt><strong>raise_when_negative_error</strong><span class="classifier">bool, default=True</span></dt><dd><p>Raise error when prediction error is negative.</p>
</dd>
<dt><strong>err_to_nan</strong><span class="classifier">bool, default=True</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">ValueError</span></code> to <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>results</strong><span class="classifier">gpd.GeoDataFrame</span></dt><dd><p>Columns = <code class="docutils literal notranslate"><span class="pre">[area_id,</span> <span class="pre">geometry</span> <span class="pre">(Point),</span> <span class="pre">prediction,</span> <span class="pre">error]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="data-download">
<h3>Data download<a class="headerlink" href="#data-download" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">download_air_quality_poland</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">export</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">export_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'air_quality_sample.csv'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/pipelines/samples.html#download_air_quality_poland"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Function downloads air quality data from Polish (Central Europe) stations. (EPSG:4326)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dataset</strong><span class="classifier">str</span></dt><dd><dl class="simple">
<dt>The observed compound from the following list:</dt><dd><ul class="simple">
<li><p>‘CO’: carbon monoxide,</p></li>
<li><p>‘SO2’: sulfur dioxide,</p></li>
<li><p>‘PM2.5’:  particulate matter with size &lt;= 2.5 micrometers,</p></li>
<li><p>‘PM10’: particulate matter with size &lt;= 10 micrometers,</p></li>
<li><p>‘NO2’: nitrogen dioxide,</p></li>
<li><p>‘03’: ozone,</p></li>
<li><p>‘C6H6’: benzene.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>export</strong><span class="classifier">bool, default = False</span></dt><dd><p>Export loaded dataset into a csv file.</p>
</dd>
<dt><strong>export_path</strong><span class="classifier">str, default = ‘air_quality_sample.csv’</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>final_df</strong><span class="classifier">DataFrame</span></dt><dd><p>columns = [station_id, x, y, reading name]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="core-data-structures">
<h2>Core data structures<a class="headerlink" href="#core-data-structures" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Blocks</span></span><a class="reference internal" href="../_modules/pyinterpolate/processing/preprocessing/blocks.html#Blocks"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Class stores and prepares aggregated data.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geocls</span> <span class="o">=</span> <span class="n">Blocks</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geocls</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="s1">&#39;testfile.shp&#39;</span><span class="p">,</span> <span class="n">value_col</span><span class="o">=</span><span class="s1">&#39;val&#39;</span><span class="p">,</span> <span class="n">geometry_col</span><span class="o">=</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="s1">&#39;idx&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parsed_columns</span> <span class="o">=</span> <span class="n">geocls</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">parsed_columns</span><span class="p">))</span>
<span class="go">(idx, val, geometry, centroid.x, centroid.y)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">gpd.GeoDataFrame</span></dt><dd><p>Dataset with block values.</p>
</dd>
<dt><strong>value_column_name</strong><span class="classifier">Any</span></dt><dd><p>Name of the column with block rates.</p>
</dd>
<dt><strong>geometry_column_name</strong><span class="classifier">Any</span></dt><dd><p>Name of the column with a block geometry.</p>
</dd>
<dt><strong>index_column_name</strong><span class="classifier">Any</span></dt><dd><p>Name of the column with the index.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>from_file(fpath, value_col, geometry_col, index_col)</strong></p></td>
<td><p>Reads and parses data from spatial file supported by GeoPandas.</p></td>
</tr>
<tr class="row-even"><td><p><strong>from_geodataframe(gdf, value_col, geometry_col, use_index)</strong></p></td>
<td><p>Reads and parses data from GeoPandas GeoDataFrame.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PointSupport</span></span><a class="reference internal" href="../_modules/pyinterpolate/processing/preprocessing/blocks.html#PointSupport"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Class prepares the point support data in relation to block dataset.</p>
<p class="rubric">Notes</p>
<p>TODO: info about regualarization process</p>
<p class="rubric">Examples</p>
<p>import geopandas as gpd
from pyinterpolate.processing.point.structure import PointSupport</p>
<p>POPULATION_DATA = “path to the point support file”
POLYGON_DATA = “path to the polygon data”
GEOMETRY_COL = “geometry”
POP10 = “POP10”
POLYGON_ID = “FIPS”</p>
<p>gdf_points = gpd.read_file(POPULATION_DATA)
gdf_polygons = gpd.read_file(POLYGON_DATA)
point_support = PointSupport()
out = point_support.from_geodataframes(gdf_points,</p>
<blockquote>
<div><p>gdf_polygons,
point_support_geometry_col=GEOMETRY_COL,
point_support_val_col=POP10,
blocks_geometry_col=GEOMETRY_COL,
blocks_index_col=POLYGON_ID)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>point_support</strong><span class="classifier">gpd.GeoDataFrame</span></dt><dd><p>Dataset with point support values and indexes of blocks (where point falls into).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>from_files()</strong></p></td>
<td><p>Loads point support and polygon data from files.</p></td>
</tr>
<tr class="row-even"><td><p><strong>from_geodataframes()</strong></p></td>
<td><p>Loads point support and polygon data from dataframe.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

</section>
<section id="variogram">
<h2>Variogram<a class="headerlink" href="#variogram" title="Permalink to this heading">¶</a></h2>
<section id="experimental">
<h3>Experimental<a class="headerlink" href="#experimental" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">build_experimental_variogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/variogram/empirical/experimental_variogram.html#build_experimental_variogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><dl class="simple">
<dt>Function prepares:</dt><dd><ul class="simple">
<li><p>experimental semivariogram,</p></li>
<li><p>experimental covariogram,</p></li>
<li><p>variance.</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_array</strong><span class="classifier">numpy array</span></dt><dd><p>coordinates and their values: (pt x, pt y, value) or (Point(), value).</p>
</dd>
<dt><strong>step_size</strong><span class="classifier">float</span></dt><dd><p>distance between lags within each points are included in the calculations.</p>
</dd>
<dt><strong>max_range</strong><span class="classifier">float</span></dt><dd><p>maximum range of analysis.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy array or None, optional, default=None</span></dt><dd><p>weights assigned to points, index of weight must be the same as index of point, if provided then
the semivariogram is weighted.</p>
</dd>
<dt><strong>direction</strong><span class="classifier">float (in range [0, 360]), optional, default=0</span></dt><dd><p>direction of semivariogram, values from 0 to 360 degrees:
* 0 or 180: is NS direction,
* 90 or 270 is EW direction,
* 45 or 225 is NE-SW direction,
* 135 or 315 is NW-SE direction.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float (in range [0, 1]), optional, default=1</span></dt><dd><p>If tolerance is 0 then points must be placed at a single line with the beginning in the origin of
the coordinate system and the angle given by y axis and direction parameter. If tolerance is &gt; 0 then
the bin is selected as an elliptical area with major axis pointed in the same direction as the line
for 0 tolerance.
* The minor axis size is (tolerance * step_size)
* The major axis size is ((1 - tolerance) * step_size)
* The baseline point is at a center of the ellipse.
Tolerance == 1 creates an omnidirectional semivariogram.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>semivariogram_stats</strong><span class="classifier">EmpiricalSemivariogram</span></dt><dd><p>The class with empirical semivariogram, empirical covariogram and variance</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_covariance</span></code></dt><dd><p>function to calculate experimental covariance and variance of a given set of points.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_semivariance</span></code></dt><dd><p>function to calculate experimental semivariance from a given set of points.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">EmpiricalSemivariogram</span></code></dt><dd><p>class that calculates and stores experimental semivariance, covariance and variance.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Function is an alias for EmpiricalSemivariogram class and it forces calculations of all spatial statistics from a</dt><dd><p>given dataset.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">REFERENCE_INPUT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">... </span>   <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">STEP_SIZE</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MAX_RANGE</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">empirical_smv</span> <span class="o">=</span> <span class="n">build_experimental_variogram</span><span class="p">(</span><span class="n">REFERENCE_INPUT</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="n">STEP_SIZE</span><span class="p">,</span> <span class="n">max_range</span><span class="o">=</span><span class="n">MAX_RANGE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">empirical_smv</span><span class="p">)</span>
<span class="go">+-----+--------------------+---------------------+--------------------+</span>
<span class="go">| lag |    semivariance    |      covariance     |    var_cov_diff    |</span>
<span class="go">+-----+--------------------+---------------------+--------------------+</span>
<span class="go">| 1.0 |       4.625        |       -0.543        |       4.792        |</span>
<span class="go">| 2.0 |       5.227        |       -0.795        |       5.043        |</span>
<span class="go">| 3.0 |        6.0         |       -1.26         |       5.509        |</span>
<span class="go">+-----+--------------------+---------------------+--------------------+</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">build_variogram_point_cloud</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/variogram/empirical/cloud.html#build_variogram_point_cloud"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><dl class="simple">
<dt>Function calculates lagged variogram point cloud. Variogram is calculated as a squared difference of each point</dt><dd><p>against other point within range specified by step_size parameter.</p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>input_array</strong><span class="classifier">numpy array</span></dt><dd><p>coordinates and their values: (pt x, pt y, value) or (Point(), value).</p>
</dd>
<dt><strong>step_size</strong><span class="classifier">float</span></dt><dd><p>distance between lags within each points are included in the calculations.</p>
</dd>
<dt><strong>max_range</strong><span class="classifier">float</span></dt><dd><p>maximum range of analysis.</p>
</dd>
<dt><strong>direction</strong><span class="classifier">float (in range [0, 360]), optional, default=0</span></dt><dd><p>direction of semivariogram, values from 0 to 360 degrees:
* 0 or 180: is NS direction,
* 90 or 270 is EW direction,
* 45 or 225 is NE-SW direction,
* 135 or 315 is NW-SE direction.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float, default=1</span></dt><dd><p>Value in range (0-1] to calculate semi-minor axis length of the search area. If tolerance is close
to 0 then points must be placed at a single line with beginning in the origin of coordinate system
and angle given by y axis and direction parameter.</p>
<blockquote>
<div><ul class="simple">
<li><p>The major axis length == step_size,</p></li>
<li><p>The minor axis size == tolerance * step_size.</p></li>
<li><p>Tolerance == 1 creates the omnidirectional semivariogram.</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>variogram_cloud</strong><span class="classifier">dict</span></dt><dd><p>{Lag: array of semivariances within a given lag}</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ExperimentalVariogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_semivariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/variogram/empirical/experimental_variogram.html#ExperimentalVariogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Class calculates Experimental Semivariogram and Experimental Covariogram of a given dataset.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>input_array</strong><span class="classifier">numpy array, list, tuple</span></dt><dd><p>As a list and numpy array: coordinates and their values: (pt x, pt y, value),
as a dict: polyset = {‘points’: numpy array with coordinates and their values},
as a Blocks: Blocks.polyset[‘points’]</p>
</dd>
<dt><strong>step_size</strong><span class="classifier">float</span></dt><dd><p>distance between lags within each points are included in the calculations.</p>
</dd>
<dt><strong>max_range</strong><span class="classifier">float</span></dt><dd><p>maximum range of analysis.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy array or None, optional, default=None</span></dt><dd><p>weights assigned to points, index of weight must be the same as index of point, if provided then
the semivariogram is weighted.</p>
</dd>
<dt><strong>direction</strong><span class="classifier">float (in range [0, 360]), optional, default=0</span></dt><dd><p>direction of semivariogram, values from 0 to 360 degrees:
* 0 or 180: is NS direction,
* 90 or 270 is EW direction,
* 45 or 225 is NE-SW direction,
* 135 or 315 is NW-SE direction.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float, default=1</span></dt><dd><p>Value in range (0-1] to calculate semi-minor axis length of the search area. If tolerance is close
to 0 then points must be placed at a single line with beginning in the origin of coordinate system
and angle given by y axis and direction parameter.</p>
<blockquote>
<div><ul class="simple">
<li><p>The major axis length == step_size,</p></li>
<li><p>The minor axis size == tolerance * step_size.</p></li>
<li><p>Tolerance == 1 creates the omnidirectional semivariogram.</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>is_semivariance</strong><span class="classifier">bool, optional, default=True</span></dt><dd><p>should semivariance be calculated?</p>
</dd>
<dt><strong>is_covariance</strong><span class="classifier">bool, optional, default=True</span></dt><dd><p>should covariance be calculated?</p>
</dd>
<dt><strong>is_variance</strong><span class="classifier">bool, optional, default=True</span></dt><dd><p>should variance be calculated?</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_covariance</span></code></dt><dd><p>function to calculate experimental covariance and variance of a given set of points.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_semivariance</span></code></dt><dd><p>function to calculate experimental semivariance from a given set of points.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">REFERENCE_INPUT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">... </span>   <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">STEP_SIZE</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MAX_RANGE</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">empirical_smv</span> <span class="o">=</span> <span class="n">ExperimentalVariogram</span><span class="p">(</span><span class="n">REFERENCE_INPUT</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="n">STEP_SIZE</span><span class="p">,</span> <span class="n">max_range</span><span class="o">=</span><span class="n">MAX_RANGE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">empirical_smv</span><span class="p">)</span>
<span class="go">+-----+--------------------+---------------------+--------------------+</span>
<span class="go">| lag |    semivariance    |      covariance     |    var_cov_diff    |</span>
<span class="go">+-----+--------------------+---------------------+--------------------+</span>
<span class="go">| 1.0 |       4.625        | -0.5434027777777798 | 4.791923487836951  |</span>
<span class="go">| 2.0 | 5.2272727272727275 | -0.7954545454545454 | 5.0439752555137165 |</span>
<span class="go">| 3.0 |        6.0         | -1.2599999999999958 | 5.508520710059168  |</span>
<span class="go">+-----+--------------------+---------------------+--------------------+</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>input_array</strong><span class="classifier">numpy array</span></dt><dd><p>The array with coordinates and observed values.</p>
</dd>
<dt><strong>experimental_semivariance_array</strong><span class="classifier">numpy array or None, optional, default=None</span></dt><dd><p>The array of semivariance per lag in the form:
(lag, semivariance, number of points within lag).</p>
</dd>
<dt><strong>experimental_covariance_array</strong><span class="classifier">numpy array or None, optional, default=None</span></dt><dd><p>The array of covariance per lag in the form:
(lag, covariance, number of points within lag).</p>
</dd>
<dt><strong>experimental_semivariances</strong><span class="classifier">numpy array or None, optional, default=None</span></dt><dd><p>The array of semivariances.</p>
</dd>
<dt><strong>experimental_covariances</strong><span class="classifier">numpy array or None, optional, default=None</span></dt><dd><p>The array of covariances, optional, default=None</p>
</dd>
<dt><strong>variance_covariances_diff</strong><span class="classifier">numpy array or None, optional, default=None</span></dt><dd><p>The array of differences c(0) - c(h).</p>
</dd>
<dt><strong>lags</strong><span class="classifier">numpy array or None, default=None</span></dt><dd><p>The array of lags (upper bound for each lag).</p>
</dd>
<dt><strong>points_per_lag</strong><span class="classifier">numpy array or None, default=None</span></dt><dd><p>A number of points in each lag-bin.</p>
</dd>
<dt><strong>variance</strong><span class="classifier">float or None, optional, default=None</span></dt><dd><p>The variance of a dataset, if data is second-order stationary then we are able to retrieve a semivariance
as a difference between the variance and the experimental covariance:</p>
<blockquote>
<div><blockquote>
<div><p>(Eq. 1)</p>
<blockquote>
<div><p>g(h) = c(0) - c(h)</p>
<p>where:</p>
<p>g(h): semivariance at a given lag h,
c(0): variance of a dataset,
c(h): covariance of a dataset.</p>
</div></blockquote>
</div></blockquote>
<p>Important! Have in mind that it works only if process is second-order stationary (variance is the same
for each distance bin) and if the semivariogram has the upper bound.
See also: variance_covariances_diff attribute.</p>
</div></blockquote>
</dd>
<dt><strong>step</strong><span class="classifier">float</span></dt><dd><p>Derived from the step_size parameter.</p>
</dd>
<dt><strong>mx_rng</strong><span class="classifier">float</span></dt><dd><p>Derived from the max_range parameter.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy array or None</span></dt><dd><p>Derived from the weights paramtere.</p>
</dd>
<dt><strong>direct: float</strong></dt><dd><p>Derived from the direction parameter.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Derived from the tolerance parameter.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>plot()</strong></p></td>
<td><p>Shows experimental variances.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">VariogramCloud</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calculate_on_creation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/variogram/empirical/cloud.html#VariogramCloud"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Class calculates Variogram Point Cloud and presents it in a scatterplot, boxplot and violinplot.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>input_array</strong><span class="classifier">numpy array</span></dt><dd><p>coordinates and their values: (pt x, pt y, value) or (Point(), value).</p>
</dd>
<dt><strong>step_size</strong><span class="classifier">float</span></dt><dd><p>distance between lags within each points are included in the calculations.</p>
</dd>
<dt><strong>max_range</strong><span class="classifier">float</span></dt><dd><p>maximum range of analysis.</p>
</dd>
<dt><strong>direction</strong><span class="classifier">float (in range [0, 360]), optional, default=0</span></dt><dd><p>direction of semivariogram, values from 0 to 360 degrees:
* 0 or 180: is NS direction,
* 90 or 270 is EW direction,
* 45 or 225 is NE-SW direction,
* 135 or 315 is NW-SE direction.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float, default=1</span></dt><dd><p>Value in range (0-1] to calculate semi-minor axis length of the search area. If tolerance is close
to 0 then points must be placed at a single line with beginning in the origin of coordinate system
and angle given by y axis and direction parameter.</p>
<blockquote>
<div><ul class="simple">
<li><p>The major axis length == step_size,</p></li>
<li><p>The minor axis size == tolerance * step_size.</p></li>
<li><p>Tolerance == 1 creates the omnidirectional semivariogram.</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_variogram_point_cloud</span></code></dt><dd><p>function to calculate variogram point cloud, class VariogramCloud is a wrapper around it.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExperimentalVariogram</span></code></dt><dd><p>class that calculates experimental semivariogram, experimental covariogram and data variance.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">REFERENCE_INPUT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">... </span>   <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">STEP_SIZE</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MAX_RANGE</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point_cloud</span> <span class="o">=</span> <span class="n">VariogramCloud</span><span class="p">(</span><span class="n">REFERENCE_INPUT</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="n">STEP_SIZE</span><span class="p">,</span> <span class="n">max_range</span><span class="o">=</span><span class="n">MAX_RANGE</span><span class="p">)</span>
<span class="go"># &gt;&gt;&gt; print(point_cloud)</span>
<span class="go"># +-----+--------------------+---------------------+--------------------+</span>
<span class="go"># | lag |    count    |      avg semivariance    |    std  | min | 25% | median | 75% | max | skewness | kurtosis |</span>
<span class="go"># +-----+--------------------+---------------------+--------------------+</span>
<span class="go"># | 1.0 |       4.625        | -0.5434027777777798 | 4.791923487836951  |</span>
<span class="go"># | 2.0 | 5.22727272727272 | -0.7954545454545454 | 5.0439752555137165 |</span>
<span class="go"># | 3.0 |        6.0         | -1.2599999999999958 | 5.508520710059168  |</span>
<span class="go"># +-----+--------------------+---------------------+--------------------+</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_array</strong><span class="classifier">numpy array</span></dt><dd><p>The array with coordinates and observed values.</p>
</dd>
<dt><strong>experimental_point_cloud</strong><span class="classifier">dict or None, default=None</span></dt><dd><p>Dict with lag: variances
{lag: [variances]}</p>
</dd>
<dt><strong>lags</strong><span class="classifier">numpy array or None, default=None</span></dt><dd><p>The array of lags (upper bound for each lag).</p>
</dd>
<dt><strong>points_per_lag</strong><span class="classifier">int or None, default=None</span></dt><dd><p>A number of points in each lag-bin.</p>
</dd>
<dt><strong>step</strong><span class="classifier">float</span></dt><dd><p>Derived from the step_size parameter.</p>
</dd>
<dt><strong>mx_rng</strong><span class="classifier">float</span></dt><dd><p>Derived from the  max_range parameter.</p>
</dd>
<dt><strong>direct: float</strong></dt><dd><p>Derived from the direction parameter.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Derived from the tolerance parameter.</p>
</dd>
<dt><strong>calculate_on_creation</strong><span class="classifier">bool, default=True</span></dt><dd><p>Perform calculations of semivariogram point cloud when object is initialized.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>calculate_experimental_variogram()</strong></p></td>
<td><p>Method calculates experimental variogram from a point cloud.</p></td>
</tr>
<tr class="row-even"><td><p><strong>describe()</strong></p></td>
<td><p>calculates statistics for point clouds. It is invoked by default by class __str__() method.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>plot(kind=’scatter’)</strong></p></td>
<td><p>plots scatterplot, boxplot or violinplot of a point cloud.</p></td>
</tr>
<tr class="row-even"><td><p><strong>remove_outliers()</strong></p></td>
<td><p>Removes outliers from a semivariance scatterplots.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

</section>
<section id="theoretical">
<h3>Theoretical<a class="headerlink" href="#theoretical" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">build_theoretical_variogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">experimental_variogram</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sill</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rang</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nugget</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/variogram/theoretical/semivariogram.html#build_theoretical_variogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Function is a wrapper into TheoreticalVariogram class and its fit() method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>experimental_variogram</strong><span class="classifier">ExperimentalVariogram</span></dt><dd></dd>
<dt><strong>model_type</strong><span class="classifier">str</span></dt><dd><p>Available types:
- ‘circular’,
- ‘cubic’,
- ‘exponential’,
- ‘gaussian’,
- ‘linear’,
- ‘power’,
- ‘spherical’.</p>
</dd>
<dt><strong>sill</strong><span class="classifier">float</span></dt><dd><p>Value at which dissimilarity is close to its maximum if model is bounded. Otherwise, it is usually close
to observations variance.</p>
</dd>
<dt><strong>rang</strong><span class="classifier">float</span></dt><dd><p>Semivariogram Range is a distance at which spatial correlation exists and often it is a distance when
variogram reaches sill. It shouldn’t be set at a distance larger than a half of a study extent.</p>
</dd>
<dt><strong>nugget</strong><span class="classifier">float, default=0.</span></dt><dd><p>Nugget parameter (bias at a zero distance).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>: TheoreticalVariogram</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">TheoreticalVariogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/variogram/theoretical/semivariogram.html#TheoreticalVariogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Theoretical model of spatial data dissimilarity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>model_params</strong><span class="classifier">dict or None, default=None</span></dt><dd><p>Dictionary with ‘nugget’, ‘sill’, ‘range’ and ‘name’ of the model.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExperimentalVariogram</span></code></dt><dd><p>class to calculate experimental variogram and more.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">REFERENCE_INPUT</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>   <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">... </span>   <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">STEP_SIZE</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MAX_RANGE</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">empirical_smv</span> <span class="o">=</span> <span class="n">ExperimentalVariogram</span><span class="p">(</span><span class="n">REFERENCE_INPUT</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="n">STEP_SIZE</span><span class="p">,</span> <span class="n">max_range</span><span class="o">=</span><span class="n">MAX_RANGE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">theoretical_smv</span> <span class="o">=</span> <span class="n">TheoreticalVariogram</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">theoretical_smv</span><span class="o">.</span><span class="n">autofit</span><span class="p">(</span><span class="n">experimental_variogram</span><span class="o">=</span><span class="n">empirical_smv</span><span class="p">,</span> <span class="n">model_types</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">theoretical_smv</span><span class="o">.</span><span class="n">rmse</span><span class="p">)</span>
<span class="go">1.5275214898546217</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>experimental_variogram</strong><span class="classifier">EmpiricalVariogram or None, default=None</span></dt><dd><p>Empirical Variogram class and its attributes.</p>
</dd>
<dt><strong>experimental_array</strong><span class="classifier">numpy array, default=None</span></dt><dd><p>Empirical variogram in a form of numpy array.</p>
</dd>
<dt><strong>variogram_models</strong><span class="classifier">dict</span></dt><dd><p>Dict with keys representing theoretical variogram models and values that
are pointing into a modeling methods. Available models:</p>
<blockquote>
<div><p>‘circular’,
‘cubic’,
‘exponential’,
‘gaussian’,
‘linear’,
‘power’,
‘spherical’.</p>
</div></blockquote>
</dd>
<dt><strong>fitted_model</strong><span class="classifier">numpy array or None</span></dt><dd><p>Trained theoretical values model. Array of [lag, variances].</p>
</dd>
<dt><strong>name</strong><span class="classifier">str or None, default=None</span></dt><dd><p>Name of the chosen model. Available names are the same as keys in variogram_models attribute.</p>
</dd>
<dt><strong>nugget</strong><span class="classifier">float, default=0</span></dt><dd><p>Nugget parameter (bias at a zero distance).</p>
</dd>
<dt><strong>sill</strong><span class="classifier">float, default=0</span></dt><dd><p>Value at which dissimilarity is close to its maximum if model is bounded. Otherwise, it is usually close
to observations variance.</p>
</dd>
<dt><strong>rang</strong><span class="classifier">float, default=0</span></dt><dd><p>Semivariogram Range is a distance at which spatial correlation exists and often it is a distance when
variogram reaches sill. It shouldn’t be set at a distance larger than a half of a study extent.</p>
</dd>
<dt><strong>rmse</strong><span class="classifier">float, default=0</span></dt><dd><p>Root mean squared error of the difference between the empirical observations and the modeled curve.</p>
</dd>
<dt><strong>mae</strong><span class="classifier">bool, default=True</span></dt><dd><p>Mean Absolute Error of a model.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">float, default=0</span></dt><dd><p>Forecast Bias of the estimation. Large positive value means that the estimated model usually underestimates
values and large negative value means that model overestimates predictions.</p>
</dd>
<dt><strong>smape</strong><span class="classifier">float, default=0</span></dt><dd><p>Symmetric Mean Absolute Percentage Error of the prediction - values from 0 to 100%.</p>
</dd>
<dt><strong>are_params</strong><span class="classifier">bool</span></dt><dd><p>Check if model parameters were given during initialization.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>fit()</strong></p></td>
<td><p>Fits experimental variogram data into theoretical model.</p></td>
</tr>
<tr class="row-even"><td><p><strong>autofit()</strong></p></td>
<td><p>The same as fit but tests multiple ranges, sills and models.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>calculate_model_error()</strong></p></td>
<td><p>Evaluates the model performance against experimental values.</p></td>
</tr>
<tr class="row-even"><td><p><strong>to_dict()</strong></p></td>
<td><p>Store model parameters in a dict.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>from_dict()</strong></p></td>
<td><p>Read model parameters from a dict.</p></td>
</tr>
<tr class="row-even"><td><p><strong>to_json()</strong></p></td>
<td><p>Save model parameteres in a JSON file.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>from_json()</strong></p></td>
<td><p>Read model parameters from a JSON file.</p></td>
</tr>
<tr class="row-even"><td><p><strong>plot()</strong></p></td>
<td><p>Shows theoretical model.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

</section>
<section id="block">
<h3>Block<a class="headerlink" href="#block" title="Permalink to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AggregatedVariogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aggregated_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">agg_step_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">agg_max_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_support</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">agg_direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">agg_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variogram_weighting_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'closest'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_process</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/variogram/regularization/aggregated.html#AggregatedVariogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Class calculates semivariance of aggregated counts.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>aggregated_data</strong><span class="classifier">Union[Blocks, gpd.GeoDataFrame, pd.DataFrame, np.ndarray]</span></dt><dd><p>Blocks with aggregated data.
* Blocks: Blocks() class object.
* GeoDataFrame and DataFrame must have columns: centroid.x, centroid.y, ds, index.</p>
<blockquote>
<div><p>Geometry column with polygons is not used and optional.</p>
</div></blockquote>
<ul class="simple">
<li><p>numpy array: [[block index, centroid x, centroid y, value]].</p></li>
</ul>
</dd>
<dt><strong>agg_step_size</strong><span class="classifier">float</span></dt><dd><p>Step size between lags.</p>
</dd>
<dt><strong>agg_max_range</strong><span class="classifier">float</span></dt><dd><p>Maximal distance of analysis.</p>
</dd>
<dt><strong>point_support</strong><span class="classifier">Union[Dict, np.ndarray, gpd.GeoDataFrame, pd.DataFrame, PointSupport]</span></dt><dd><ul class="simple">
<li><p>Dict: {block id: [[point x, point y, value]]}</p></li>
<li><p>numpy array: [[block id, x, y, value]]</p></li>
<li><p>DataFrame and GeoDataFrame: columns={x, y, ds, index}</p></li>
<li><p>PointSupport</p></li>
</ul>
</dd>
<dt><strong>agg_direction</strong><span class="classifier">float (in range [0, 360]), optional, default=0</span></dt><dd><p>direction of semivariogram, values from 0 to 360 degrees:
* 0 or 180: is NS direction,
* 90 or 270 is EW direction,
* 45 or 225 is NE-SW direction,
* 135 or 315 is NW-SE direction.</p>
</dd>
<dt><strong>agg_tolerance</strong><span class="classifier">float (in range [0, 1]), optional, default=1</span></dt><dd><p>If tolerance is 0 then points must be placed at a single line with the beginning in the origin of
the coordinate system and the angle given by y axis and direction parameter. If tolerance is &gt; 0
then the bin is selected as an elliptical area with major axis pointed in the same direction as
the line for 0 tolerance.
* The minor axis size is (tolerance * step_size)
* The major axis size is ((1 - tolerance) * step_size)
* The baseline point is at a center of the ellipse.
Tolerance == 1 creates an omnidirectional semivariogram.</p>
</dd>
<dt><strong>variogram_weighting_method</strong><span class="classifier">str, default = “closest”</span></dt><dd><p>Method used to weight error at a given lags. Available methods:
- equal: no weighting,
- closest: lags at a close range have bigger weights,
- distant: lags that are further away have bigger weights,
- dense: error is weighted by the number of point pairs within a lag - more pairs,</p>
<blockquote>
<div><p>lesser weight.</p>
</div></blockquote>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, default = False</span></dt><dd><p>Print steps performed by the algorithm.</p>
</dd>
<dt><strong>log_process</strong><span class="classifier">bool, default = False</span></dt><dd><p>Log process info (Level DEBUG).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Goovaerts P., Kriging and Semivariogram Deconvolution in the Presence of Irregular Geographical
Units, Mathematical Geology 40(1), 101-128, 2008</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>aggregated_data</strong><span class="classifier">Union[Blocks, Dict, gpd.GeoDataFrame, pd.DataFrame, np.ndarray]</span></dt><dd><p>See aggregared_data parameter.</p>
</dd>
<dt><strong>agg_step_size</strong><span class="classifier">float</span></dt><dd><p>See agg_step_size parameter.</p>
</dd>
<dt><strong>agg_max_range</strong><span class="classifier">float</span></dt><dd><p>See agg_max_range parameter.</p>
</dd>
<dt><strong>agg_lags</strong><span class="classifier">numpy array</span></dt><dd><p>Lags calculates as a set of equidistant points from agg_step_size to agg_max_range with a step of size
agg_step_size.</p>
</dd>
<dt><strong>agg_tolerance</strong><span class="classifier">float, default = 1</span></dt><dd><p>See agg_tolerance parameter.</p>
</dd>
<dt><strong>agg_direction</strong><span class="classifier">float, default = 0</span></dt><dd><p>See agg_direction parameter.</p>
</dd>
<dt><strong>point_support</strong><span class="classifier">Union[Dict, np.ndarray, gpd.GeoDataFrame, pd.DataFrame, PointSupport]</span></dt><dd><p>See point_support parameter.</p>
</dd>
<dt><strong>weighting_method</strong><span class="classifier">str, default = ‘closest’</span></dt><dd><p>See variogram_weighting_method parameter.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, default = False</span></dt><dd><p>See vebose parameter.</p>
</dd>
<dt><strong>log_process</strong><span class="classifier">bool, default = False</span></dt><dd><p>See log_process parameter.</p>
</dd>
<dt><strong>experimental_variogram</strong><span class="classifier">ExperimentalVariogram</span></dt><dd><p>The experimental variogram calculated from blocks (their centroids).</p>
</dd>
<dt><strong>theoretical_model</strong><span class="classifier">TheoreticalVariogram</span></dt><dd><p>The theoretical model derived from blocks’ centroids.</p>
</dd>
<dt><strong>inblock_semivariance</strong><span class="classifier">Dict</span></dt><dd><p>{area id: the average inblock semivariance}</p>
</dd>
<dt><strong>avg_inblock_semivariance</strong><span class="classifier">numpy array</span></dt><dd><p>[lag, average inblocks semivariances, number of blocks within a lag]</p>
</dd>
<dt><strong>block_to_block_semivariance</strong><span class="classifier">Dict</span></dt><dd><p>{(block i, block j): [distance, semivariance, number of point pairs between blocks]}</p>
</dd>
<dt><strong>avg_block_to_block_semivariance</strong><span class="classifier">numpy array</span></dt><dd><p>[lag, semivariance, number of point pairs between blocks].</p>
</dd>
<dt><strong>regularized_variogram</strong><span class="classifier">numpy array</span></dt><dd><p>[lag, semivariance]</p>
</dd>
<dt><strong>distances_between_blocks</strong><span class="classifier">Dict</span></dt><dd><p>Weighted distances between all blocks: {block id : [distances to other blocks]}.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>regularize()</strong></p></td>
<td><p>Method performs semivariogram regularization.</p></td>
</tr>
<tr class="row-even"><td><p><strong>show_semivariograms()</strong></p></td>
<td><p>Shows experimental variogram, theoretical model, average inblock semivariance, average block to block semivariance and regularized variogram.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

</section>
<section id="deconvolution">
<h3>Deconvolution<a class="headerlink" href="#deconvolution" title="Permalink to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Deconvolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_models</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/variogram/regularization/deconvolution.html#Deconvolution"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Class performs deconvolution of semivariogram of areal data. Whole procedure is based on the iterative process
described in: [1].</p>
<p>Steps to regularize semivariogram:
- initialize your object (no parameters),
- use fit() method to build initial point support model,
- use transform() method to perform semivariogram regularization,
- save deconvoluted semivariogram model with export_model() method.</p>
<p class="rubric">References</p>
<p>[1] Goovaerts P., Kriging and Semivariogram Deconvolution in the Presence of Irregular Geographical
Units, Mathematical Geology 40(1), 101-128, 2008</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dcv</span> <span class="o">=</span> <span class="n">Deconvolution</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dcv</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">agg_dataset</span><span class="o">=...</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">point_support_dataset</span><span class="o">=...</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">agg_step_size</span><span class="o">=...</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">agg_max_range</span><span class="o">=...</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">variogram_weighting_method</span><span class="o">=</span><span class="s1">&#39;closest&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dcv</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">max_iters</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dcv</span><span class="o">.</span><span class="n">plot_variograms</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dcv</span><span class="o">.</span><span class="n">plot_deviations</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dcv</span><span class="o">.</span><span class="n">plot_weights</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dcv</span><span class="o">.</span><span class="n">export_model</span><span class="p">(</span><span class="s1">&#39;results.csv&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ps</strong><span class="classifier">Union[Dict, np.ndarray, gpd.GeoDataFrame, pd.DataFrame, PointSupport]</span></dt><dd><ul class="simple">
<li><p>Dict: {block id: [[point x, point y, value]]}</p></li>
<li><p>numpy array: [[block id, x, y, value]]</p></li>
<li><p>DataFrame and GeoDataFrame: columns={x, y, ds, index}</p></li>
<li><p>PointSupport</p></li>
</ul>
</dd>
<dt><strong>agg</strong><span class="classifier">Union[Blocks, gpd.GeoDataFrame, pd.DataFrame, np.ndarray]</span></dt><dd><p>Blocks with aggregated data.
* Blocks: Blocks() class object.
* GeoDataFrame and DataFrame must have columns: centroid.x, centroid.y, ds, index.</p>
<blockquote>
<div><p>Geometry column with polygons is not used and optional.</p>
</div></blockquote>
<ul class="simple">
<li><p>numpy array: [[block index, centroid x, centroid y, value]].</p></li>
</ul>
</dd>
<dt><strong>initial_regularized_variogram</strong><span class="classifier">numpy array</span></dt><dd><p>[lag, semivariance]</p>
</dd>
<dt><strong>initial_theoretical_agg_model</strong><span class="classifier">TheoreticalVariogram</span></dt><dd></dd>
<dt><strong>initial_theoretical_model_prediction</strong><span class="classifier">numpy array</span></dt><dd><p>[lag, semivariance]</p>
</dd>
<dt><strong>initial_experimental_variogram</strong><span class="classifier">numpy array</span></dt><dd><p>[lag, semivariance, number of pairs]</p>
</dd>
<dt><strong>final_theoretical_model</strong><span class="classifier">TheoreticalVariogram</span></dt><dd></dd>
<dt><strong>final_optimal_variogram</strong><span class="classifier">numpy array</span></dt><dd><p>[lag, semivariance]</p>
</dd>
<dt><strong>agg_step</strong><span class="classifier">float</span></dt><dd><p>Step size between lags.</p>
</dd>
<dt><strong>agg_rng</strong><span class="classifier">float</span></dt><dd><p>Maximal distance of analysis.</p>
</dd>
<dt><strong>ranges</strong><span class="classifier">numpy array</span></dt><dd><p>np.arange(agg_step, agg_rng, agg_step)</p>
</dd>
<dt><strong>direction</strong><span class="classifier">float (in range [0, 360])</span></dt><dd><p>Direction of semivariogram, values from 0 to 360 degrees:
* 0 or 180: is NS direction,
* 90 or 270 is EW direction,
* 45 or 225 is NE-SW direction,
* 135 or 315 is NW-SE direction.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float (in range [0, 1])</span></dt><dd><p>If tolerance is 0 then points must be placed at a single line with the beginning in the origin of
the coordinate system and the angle given by y axis and direction parameter. If tolerance is &gt; 0
then the bin is selected as an elliptical area with major axis pointed in the same direction as
the line for 0 tolerance.
* The minor axis size is (tolerance * step_size)
* The major axis size is ((1 - tolerance) * step_size)
* The baseline point is at a center of the ellipse.
Tolerance == 1 creates an omnidirectional semivariogram.</p>
</dd>
<dt><strong>weighting_method</strong><span class="classifier">str</span></dt><dd><p>Method used to weight error at a given lags. Available methods:
* equal: no weighting,
* closest: lags at a close range have bigger weights,
* distant: lags that are further away have bigger weights,
* dense: error is weighted by the number of point pairs within a lag - more pairs,</p>
<blockquote>
<div><p>lesser weight.</p>
</div></blockquote>
</dd>
<dt><strong>deviations</strong><span class="classifier">List</span></dt><dd><p>List of deviations per iteration. The first element is the initial deviation.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">List</span></dt><dd><p>List of weights applied to lags in each iteration.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>Should algorithm print() process steps into a terminal.</p>
</dd>
<dt><strong>store_models</strong><span class="classifier">bool</span></dt><dd><p>Should theoretical and regularized models be stored in each iteration.</p>
</dd>
<dt><strong>theoretical_models</strong><span class="classifier">List</span></dt><dd><p>List with theoretical models parameters.</p>
</dd>
<dt><strong>regularized_models</strong><span class="classifier">List</span></dt><dd><p>List with numpy arrays with regularized models.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>fit()</strong></p></td>
<td><p>Fits areal data and the point support data into a model, initializes the experimental semivariogram, the theoretical semivariogram model, regularized point support model, and deviation.</p></td>
</tr>
<tr class="row-even"><td><p><strong>transform()</strong></p></td>
<td><p>Performs semivariogram regularization.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>fit_transform()</strong></p></td>
<td><p>Performs fit() and transform() at one time.</p></td>
</tr>
<tr class="row-even"><td><p><strong>export_model()</strong></p></td>
<td><p>Exports regularized (or fitted) model.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>plot_variograms()</strong></p></td>
<td><p>Plots semivariances before and after regularization.</p></td>
</tr>
<tr class="row-even"><td><p><strong>plot_deviations()</strong></p></td>
<td><p>Plots each deviation divided by the initial deviation.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>plot_weights()</strong></p></td>
<td><p>Plots the mean weight value per lag.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

</section>
</section>
<section id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">interpolate_raster</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">semivariogram_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyinterpolate/viz/raster.html#interpolate_raster"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Function interpolates raster from data points using ordinary kriging.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">numpy array</span></dt><dd><p>[coordinate x, coordinate y, value].</p>
</dd>
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>Number of pixels (points) of a larger dimension (it could be width or height). Ratio is preserved.</p>
</dd>
<dt><strong>number_of_neighbors</strong><span class="classifier">int, default=16</span></dt><dd><p>Number of points used to interpolate data.</p>
</dd>
<dt><strong>semivariogram_model</strong><span class="classifier">TheoreticalVariogram, default=None</span></dt><dd><p>Variogram model, if not provided then it is estimated from a given dataset.</p>
</dd>
<dt><strong>direction</strong><span class="classifier">float, default=0</span></dt><dd><dl class="simple">
<dt>Direction of semivariogram, values from 0 to 360 degrees:</dt><dd><ul class="simple">
<li><p>0 or 180: is NS,</p></li>
<li><p>90 or 270 is EW,</p></li>
<li><p>45 or 225 is NE-SW,</p></li>
<li><p>135 or 315 is NW-SE.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float, default=1</span></dt><dd><p>Value in range (0-1) normalized to [0 : 0.5] to select tolerance of semivariogram. If tolerance
is 0 then points must be placed at a single line with beginning in the origin of coordinate system
and angle given by y axis and direction parameter. If tolerance is greater than 0 then
semivariance is estimated from elliptical area with major axis with the same direction as the line
for 0 tolerance and minor axis of a size:</p>
<blockquote>
<div><p>(tolerance * step_size)</p>
</div></blockquote>
<dl class="simple">
<dt>and major axis (pointed in NS direction):</dt><dd><p>((1 - tolerance) * step_size)</p>
</dd>
</dl>
<p>and baseline point at a center of ellipse. Tolerance == 1 (normalized to 0.5) creates omnidirectional
semivariogram.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt>: Dict</dt><dd><dl>
<dt>{</dt><dd><p>‘result’: numpy array of interpolated values,
‘error’: numpy array of interpolation errors,
‘params’: {</p>
<blockquote>
<div><p>‘pixel size’: float,
‘min x’: float,
‘max x’: float,
‘min y’: float,
‘max y’: float</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2022, Szymon Moliński.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.1.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>